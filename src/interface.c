/* interface.c generated by valac 0.44.3, the Vala compiler
 * generated from interface.vala, do not modify */

#include <glib-object.h>
#include <gee.h>
#include <glib.h>
#include <gserial.h>
#include <stdio.h>
#include <gio/gio.h>

typedef enum  {
	PICOLAN_PACKET_INVALID,
	PICOLAN_PACKET_GET_ADDR_LIST,
	PICOLAN_PACKET_ADDR,
	PICOLAN_PACKET_PING,
	PICOLAN_PACKET_PING_ECHO,
	PICOLAN_PACKET_DATAGRAM,
	PICOLAN_PACKET_SUBSCRIBE,
	PICOLAN_PACKET_NULL
} picolanPACKET;

#define PICOLAN_TYPE_PACKET (picolan_packet_get_type ())
typedef enum  {
	PICOLAN_STATE_START,
	PICOLAN_STATE_ID,
	PICOLAN_STATE_SIZE,
	PICOLAN_STATE_DATA,
	PICOLAN_STATE_CHECK1,
	PICOLAN_STATE_CHECK2
} picolanSTATE;

#define PICOLAN_TYPE_STATE (picolan_state_get_type ())

#define PICOLAN_TYPE_PARSER (picolan_parser_get_type ())
#define PICOLAN_PARSER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PICOLAN_TYPE_PARSER, picolanParser))
#define PICOLAN_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PICOLAN_TYPE_PARSER, picolanParserClass))
#define PICOLAN_IS_PARSER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PICOLAN_TYPE_PARSER))
#define PICOLAN_IS_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PICOLAN_TYPE_PARSER))
#define PICOLAN_PARSER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PICOLAN_TYPE_PARSER, picolanParserClass))

typedef struct _picolanParser picolanParser;
typedef struct _picolanParserClass picolanParserClass;
typedef struct _picolanParserPrivate picolanParserPrivate;
enum  {
	PICOLAN_PARSER_0_PROPERTY,
	PICOLAN_PARSER_NUM_PROPERTIES
};
static GParamSpec* picolan_parser_properties[PICOLAN_PARSER_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
enum  {
	PICOLAN_PARSER_ON_GET_ADDR_LIST_SIGNAL,
	PICOLAN_PARSER_ON_ADDR_SIGNAL,
	PICOLAN_PARSER_ON_PING_SIGNAL,
	PICOLAN_PARSER_ON_PING_ECHO_SIGNAL,
	PICOLAN_PARSER_ON_DATAGRAM_SIGNAL,
	PICOLAN_PARSER_NUM_SIGNALS
};
static guint picolan_parser_signals[PICOLAN_PARSER_NUM_SIGNALS] = {0};

#define PICOLAN_TYPE_INTERFACE (picolan_interface_get_type ())
#define PICOLAN_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PICOLAN_TYPE_INTERFACE, picolanInterface))
#define PICOLAN_INTERFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PICOLAN_TYPE_INTERFACE, picolanInterfaceClass))
#define PICOLAN_IS_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PICOLAN_TYPE_INTERFACE))
#define PICOLAN_IS_INTERFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PICOLAN_TYPE_INTERFACE))
#define PICOLAN_INTERFACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PICOLAN_TYPE_INTERFACE, picolanInterfaceClass))

typedef struct _picolanInterface picolanInterface;
typedef struct _picolanInterfaceClass picolanInterfaceClass;
typedef struct _picolanInterfacePrivate picolanInterfacePrivate;

#define PICOLAN_TYPE_SOCKET (picolan_socket_get_type ())
#define PICOLAN_SOCKET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PICOLAN_TYPE_SOCKET, picolanSocket))
#define PICOLAN_IS_SOCKET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PICOLAN_TYPE_SOCKET))
#define PICOLAN_SOCKET_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), PICOLAN_TYPE_SOCKET, picolanSocketIface))

typedef struct _picolanSocket picolanSocket;
typedef struct _picolanSocketIface picolanSocketIface;
enum  {
	PICOLAN_INTERFACE_0_PROPERTY,
	PICOLAN_INTERFACE_NUM_PROPERTIES
};
static GParamSpec* picolan_interface_properties[PICOLAN_INTERFACE_NUM_PROPERTIES];
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_array_unref0(var) ((var == NULL) ? NULL : (var = (g_array_unref (var), NULL)))
typedef struct _Block1Data Block1Data;

#define PICOLAN_TYPE_ADDRESS_FIELD (picolan_address_field_get_type ())
#define PICOLAN_ADDRESS_FIELD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PICOLAN_TYPE_ADDRESS_FIELD, picolanAddressField))
#define PICOLAN_ADDRESS_FIELD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PICOLAN_TYPE_ADDRESS_FIELD, picolanAddressFieldClass))
#define PICOLAN_IS_ADDRESS_FIELD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PICOLAN_TYPE_ADDRESS_FIELD))
#define PICOLAN_IS_ADDRESS_FIELD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PICOLAN_TYPE_ADDRESS_FIELD))
#define PICOLAN_ADDRESS_FIELD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PICOLAN_TYPE_ADDRESS_FIELD, picolanAddressFieldClass))

typedef struct _picolanAddressField picolanAddressField;
typedef struct _picolanAddressFieldClass picolanAddressFieldClass;
#define _picolan_address_field_unref0(var) ((var == NULL) ? NULL : (var = (picolan_address_field_unref (var), NULL)))
typedef struct _Block2Data Block2Data;
#define _g_timer_destroy0(var) ((var == NULL) ? NULL : (var = (g_timer_destroy (var), NULL)))
typedef struct _PicolanInterfacePingData PicolanInterfacePingData;
typedef struct _Block3Data Block3Data;
enum  {
	PICOLAN_INTERFACE_ON_CLOSE_SIGNAL,
	PICOLAN_INTERFACE_ON_DATAGRAM_SIGNAL,
	PICOLAN_INTERFACE_NUM_SIGNALS
};
static guint picolan_interface_signals[PICOLAN_INTERFACE_NUM_SIGNALS] = {0};
typedef struct _Block4Data Block4Data;

#define PICOLAN_TYPE_DATAGRAM (picolan_datagram_get_type ())
#define PICOLAN_DATAGRAM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PICOLAN_TYPE_DATAGRAM, picolanDatagram))
#define PICOLAN_DATAGRAM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PICOLAN_TYPE_DATAGRAM, picolanDatagramClass))
#define PICOLAN_IS_DATAGRAM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PICOLAN_TYPE_DATAGRAM))
#define PICOLAN_IS_DATAGRAM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PICOLAN_TYPE_DATAGRAM))
#define PICOLAN_DATAGRAM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PICOLAN_TYPE_DATAGRAM, picolanDatagramClass))

typedef struct _picolanDatagram picolanDatagram;
typedef struct _picolanDatagramClass picolanDatagramClass;
typedef struct _Block5Data Block5Data;
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))

struct _picolanParser {
	GObject parent_instance;
	picolanParserPrivate * priv;
};

struct _picolanParserClass {
	GObjectClass parent_class;
};

struct _picolanParserPrivate {
	GeeArrayList* data;
	guint8 id;
	guint8 size;
	picolanSTATE state;
	guint8 check1;
	guint8 check2;
	gboolean stuff_flag;
};

typedef enum  {
	PICOLAN_PICOLAN_ERROR_COMS_FAULT,
	PICOLAN_PICOLAN_ERROR_PAYLOAD_TOO_BIG
} picolanPicolanError;
#define PICOLAN_PICOLAN_ERROR picolan_picolan_error_quark ()
struct _picolanInterface {
	GObject parent_instance;
	picolanInterfacePrivate * priv;
	guint8 ttl;
};

struct _picolanInterfaceClass {
	GObjectClass parent_class;
};

struct _picolanSocketIface {
	GTypeInterface parent_iface;
	guint8 (*get_port) (picolanSocket* self);
	void (*bind) (picolanSocket* self, picolanInterface* iface);
};

struct _picolanInterfacePrivate {
	guint8 address;
	gserialPort* port;
	picolanParser* parser;
	GeeHashMap* port_map;
};

struct _Block1Data {
	int _ref_count_;
	picolanInterface* self;
	picolanSocket* s;
};

struct _Block2Data {
	int _ref_count_;
	picolanInterface* self;
	GSourceFunc callback;
	gpointer callback_target;
	GDestroyNotify callback_target_destroy_notify;
	guint8 payload1;
	guint8 payload2;
	gint ping_time;
	GTimer* timer;
	guint timeout_handle;
	gulong handle;
	gpointer _async_data_;
};

struct _PicolanInterfacePingData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GAsyncReadyCallback _callback_;
	gboolean _task_complete_;
	picolanInterface* self;
	guint8 addr;
	guint timeout;
	gint result;
	Block2Data* _data2_;
	GTimer* _tmp0_;
	picolanParser* _tmp1_;
	gulong _tmp2_;
	GeeArrayList* msg;
	GeeArrayList* _tmp3_;
	GeeArrayList* _tmp4_;
	GeeArrayList* _tmp5_;
	GeeArrayList* _tmp6_;
	GeeArrayList* _tmp7_;
	GeeArrayList* _tmp8_;
	GeeArrayList* _tmp9_;
	GeeArrayList* _tmp10_;
	gint cs1;
	gint cs2;
	GeeArrayList* _tmp11_;
	gint _tmp12_;
	gint _tmp13_;
	GeeArrayList* _tmp14_;
	GeeArrayList* _tmp15_;
	GeeArrayList* _tmp16_;
	GeeArrayList* _tmp17_;
	GeeArrayList* _tmp18_;
	GeeArrayList* _tmp19_;
	GeeArrayList* _tmp20_;
	GError* _inner_error0_;
};

struct _Block3Data {
	int _ref_count_;
	picolanInterface* self;
	GArray* arr;
};

struct _Block4Data {
	int _ref_count_;
	picolanInterface* iface;
};

struct _Block5Data {
	int _ref_count_;
	Block4Data * _data4_;
	picolanDatagram* dg;
};

static gint picolanParser_private_offset;
static gpointer picolan_parser_parent_class = NULL;
static gint picolanInterface_private_offset;
static gpointer picolan_interface_parent_class = NULL;

GType picolan_packet_get_type (void) G_GNUC_CONST;
GType picolan_state_get_type (void) G_GNUC_CONST;
void picolan_make_checksum (GeeArrayList* bytes,
                            gint* sum1,
                            gint* sum2);
GType picolan_parser_get_type (void) G_GNUC_CONST;
picolanParser* picolan_parser_new (void);
picolanParser* picolan_parser_construct (GType object_type);
void picolan_parser_read (picolanParser* self,
                          guint8 b);
static void picolan_parser_parse_packet (picolanParser* self);
static void g_cclosure_user_marshal_VOID__UCHAR_UCHAR_UCHAR_UCHAR (GClosure * closure,
                                                            GValue * return_value,
                                                            guint n_param_values,
                                                            const GValue * param_values,
                                                            gpointer invocation_hint,
                                                            gpointer marshal_data);
static void g_cclosure_user_marshal_VOID__UCHAR_UCHAR_UCHAR_OBJECT (GClosure * closure,
                                                             GValue * return_value,
                                                             guint n_param_values,
                                                             const GValue * param_values,
                                                             gpointer invocation_hint,
                                                             gpointer marshal_data);
static void picolan_parser_finalize (GObject * obj);
GQuark picolan_picolan_error_quark (void);
GType picolan_interface_get_type (void) G_GNUC_CONST;
GType picolan_socket_get_type (void) G_GNUC_CONST;
picolanInterface* picolan_interface_new (void);
picolanInterface* picolan_interface_construct (GType object_type);
static void __lambda4_ (picolanInterface* self,
                 guint8 src,
                 guint8 dest,
                 guint8 p1,
                 guint8 p2);
static GeeArrayList* picolan_interface_stuff_bytes (picolanInterface* self,
                                             GeeArrayList* bytes);
static void picolan_interface_write_byte_array (picolanInterface* self,
                                         GeeArrayList* buf,
                                         GError** error);
static void ___lambda4__picolan_parser_on_ping (picolanParser* _sender,
                                         guint8 src,
                                         guint8 dest,
                                         guint8 p1,
                                         guint8 p2,
                                         gpointer self);
static void __lambda6_ (picolanInterface* self);
void picolan_interface_set_address (picolanInterface* self,
                                    guint8 addr,
                                    GError** error);
static void ___lambda6__picolan_parser_on_get_addr_list (picolanParser* _sender,
                                                  gpointer self);
static void __lambda7_ (picolanInterface* self,
                 guint8 src,
                 guint8 dest,
                 guint8 port,
                 GeeArrayList* payload);
static void ___lambda7__picolan_parser_on_datagram (picolanParser* _sender,
                                             guint8 src,
                                             guint8 dest,
                                             guint8 port,
                                             GeeArrayList* payload,
                                             gpointer self);
static gboolean __lambda8_ (picolanInterface* self);
static gboolean ___lambda8__gsource_func (gpointer self);
gboolean picolan_interface_attach_socket (picolanInterface* self,
                                          picolanSocket* s);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
guint8 picolan_socket_get_port (picolanSocket* self);
static void ___lambda9_ (Block1Data* _data1_);
static void ____lambda9__picolan_socket_on_destroy (picolanSocket* _sender,
                                             gpointer self);
gboolean picolan_interface_open (picolanInterface* self,
                                 const gchar* port_name,
                                 gint baud,
                                 GError** error);
void picolan_interface_close (picolanInterface* self);
gpointer picolan_address_field_ref (gpointer instance);
void picolan_address_field_unref (gpointer instance);
GParamSpec* picolan_param_spec_address_field (const gchar* name,
                                              const gchar* nick,
                                              const gchar* blurb,
                                              GType object_type,
                                              GParamFlags flags);
void picolan_value_set_address_field (GValue* value,
                                      gpointer v_object);
void picolan_value_take_address_field (GValue* value,
                                       gpointer v_object);
gpointer picolan_value_get_address_field (const GValue* value);
GType picolan_address_field_get_type (void) G_GNUC_CONST;
picolanAddressField* picolan_address_field_new (void);
picolanAddressField* picolan_address_field_construct (GType object_type);
void picolan_address_field_set_address (picolanAddressField* self,
                                        guint8 addr);
guint8* picolan_address_field_get_bytes (picolanAddressField* self,
                                         gint* result_length1);
void picolan_interface_send_datagram (picolanInterface* self,
                                      guint8 dest,
                                      guint8 port,
                                      GeeArrayList* data,
                                      GError** error);
static void picolan_interface_ping_data_free (gpointer _data);
static void picolan_interface_ping_async_ready_wrapper (GObject *source_object,
                                                 GAsyncResult *res,
                                                 void *user_data);
void picolan_interface_ping (picolanInterface* self,
                             guint8 addr,
                             guint timeout,
                             GAsyncReadyCallback _callback_,
                             gpointer _user_data_);
gint picolan_interface_ping_finish (picolanInterface* self,
                                    GAsyncResult* _res_,
                                    GError** error);
static gboolean picolan_interface_ping_co (PicolanInterfacePingData* _data_);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
static gboolean _picolan_interface_ping_co_gsource_func (gpointer self);
static void __lambda10_ (Block2Data* _data2_,
                  guint8 src,
                  guint8 dest,
                  guint8 p1,
                  guint8 p2);
static void ___lambda10__picolan_parser_on_ping_echo (picolanParser* _sender,
                                               guint8 src,
                                               guint8 dest,
                                               guint8 p1,
                                               guint8 p2,
                                               gpointer self);
static gboolean __lambda11_ (Block2Data* _data2_);
static gboolean ___lambda11__gsource_func (gpointer self);
void picolan_interface_subscribe (picolanInterface* self,
                                  guint8 port,
                                  GError** error);
void picolan_interface_unsubscribe (picolanInterface* self,
                                    guint8 port,
                                    GError** error);
static Block3Data* block3_data_ref (Block3Data* _data3_);
static void block3_data_unref (void * _userdata_);
static gboolean __lambda5_ (Block3Data* _data3_,
                     guint8 item);
static gboolean ___lambda5__gee_forall_func (gpointer g,
                                      gpointer self);
static void picolan_interface_finalize (GObject * obj);
gint _vala_main (void);
static Block4Data* block4_data_ref (Block4Data* _data4_);
static void block4_data_unref (void * _userdata_);
GType picolan_datagram_get_type (void) G_GNUC_CONST;
static Block5Data* block5_data_ref (Block5Data* _data5_);
static void block5_data_unref (void * _userdata_);
static void ___lambda16_ (void);
static void ____lambda16__picolan_interface_on_close (picolanInterface* _sender,
                                               gpointer self);
static void ___lambda17_ (Block5Data* _data5_,
                   GObject* obj,
                   GAsyncResult* res);
static void ____lambda17__gasync_ready_callback (GObject* source_object,
                                          GAsyncResult* res,
                                          gpointer self);
picolanDatagram* picolan_datagram_new (guint8 _port);
picolanDatagram* picolan_datagram_construct (GType object_type,
                                             guint8 _port);
void picolan_socket_bind (picolanSocket* self,
                          picolanInterface* iface);
static void ___lambda18_ (GeeArrayList* data);
static void ____lambda18__picolan_socket_on_data (picolanSocket* _sender,
                                           GeeArrayList* data,
                                           gpointer self);
static gboolean ___lambda19_ (Block5Data* _data5_);
void picolan_datagram_send_string (picolanDatagram* self,
                                   guint8 dest,
                                   guint8 port,
                                   const gchar* str,
                                   GError** error);
static gboolean ____lambda19__gsource_func (gpointer self);

GType
picolan_packet_get_type (void)
{
	static volatile gsize picolan_packet_type_id__volatile = 0;
	if (g_once_init_enter (&picolan_packet_type_id__volatile)) {
		static const GEnumValue values[] = {{PICOLAN_PACKET_INVALID, "PICOLAN_PACKET_INVALID", "invalid"}, {PICOLAN_PACKET_GET_ADDR_LIST, "PICOLAN_PACKET_GET_ADDR_LIST", "get-addr-list"}, {PICOLAN_PACKET_ADDR, "PICOLAN_PACKET_ADDR", "addr"}, {PICOLAN_PACKET_PING, "PICOLAN_PACKET_PING", "ping"}, {PICOLAN_PACKET_PING_ECHO, "PICOLAN_PACKET_PING_ECHO", "ping-echo"}, {PICOLAN_PACKET_DATAGRAM, "PICOLAN_PACKET_DATAGRAM", "datagram"}, {PICOLAN_PACKET_SUBSCRIBE, "PICOLAN_PACKET_SUBSCRIBE", "subscribe"}, {PICOLAN_PACKET_NULL, "PICOLAN_PACKET_NULL", "null"}, {0, NULL, NULL}};
		GType picolan_packet_type_id;
		picolan_packet_type_id = g_enum_register_static ("picolanPACKET", values);
		g_once_init_leave (&picolan_packet_type_id__volatile, picolan_packet_type_id);
	}
	return picolan_packet_type_id__volatile;
}

GType
picolan_state_get_type (void)
{
	static volatile gsize picolan_state_type_id__volatile = 0;
	if (g_once_init_enter (&picolan_state_type_id__volatile)) {
		static const GEnumValue values[] = {{PICOLAN_STATE_START, "PICOLAN_STATE_START", "start"}, {PICOLAN_STATE_ID, "PICOLAN_STATE_ID", "id"}, {PICOLAN_STATE_SIZE, "PICOLAN_STATE_SIZE", "size"}, {PICOLAN_STATE_DATA, "PICOLAN_STATE_DATA", "data"}, {PICOLAN_STATE_CHECK1, "PICOLAN_STATE_CHECK1", "check1"}, {PICOLAN_STATE_CHECK2, "PICOLAN_STATE_CHECK2", "check2"}, {0, NULL, NULL}};
		GType picolan_state_type_id;
		picolan_state_type_id = g_enum_register_static ("picolanSTATE", values);
		g_once_init_leave (&picolan_state_type_id__volatile, picolan_state_type_id);
	}
	return picolan_state_type_id__volatile;
}

void
picolan_make_checksum (GeeArrayList* bytes,
                       gint* sum1,
                       gint* sum2)
{
	gint _vala_sum1 = 0;
	gint _vala_sum2 = 0;
	gint index = 0;
	g_return_if_fail (bytes != NULL);
	index = 0;
	_vala_sum2 = 0;
	_vala_sum1 = _vala_sum2;
	{
		gboolean _tmp0_ = FALSE;
		index = 0;
		_tmp0_ = TRUE;
		while (TRUE) {
			gint _tmp2_;
			gint _tmp3_;
			gpointer _tmp4_;
			if (!_tmp0_) {
				gint _tmp1_;
				_tmp1_ = index;
				index = _tmp1_ + 1;
			}
			_tmp0_ = FALSE;
			_tmp2_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) bytes);
			_tmp3_ = _tmp2_;
			if (!(index < _tmp3_)) {
				break;
			}
			_tmp4_ = gee_abstract_list_get ((GeeAbstractList*) bytes, index);
			_vala_sum1 = (_vala_sum1 + ((guint8) ((guintptr) _tmp4_))) % 255;
			_vala_sum2 = (_vala_sum2 + _vala_sum1) % 255;
		}
	}
	if (sum1) {
		*sum1 = _vala_sum1;
	}
	if (sum2) {
		*sum2 = _vala_sum2;
	}
}

static inline gpointer
picolan_parser_get_instance_private (picolanParser* self)
{
	return G_STRUCT_MEMBER_P (self, picolanParser_private_offset);
}

picolanParser*
picolan_parser_construct (GType object_type)
{
	picolanParser * self = NULL;
	GeeArrayList* _tmp0_;
	self = (picolanParser*) g_object_new (object_type, NULL);
	_tmp0_ = gee_array_list_new (G_TYPE_UCHAR, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->data);
	self->priv->data = _tmp0_;
	return self;
}

picolanParser*
picolan_parser_new (void)
{
	return picolan_parser_construct (PICOLAN_TYPE_PARSER);
}

void
picolan_parser_read (picolanParser* self,
                     guint8 b)
{
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	if (((gint) b) == 0xAA) {
		_tmp0_ = self->priv->stuff_flag == FALSE;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		self->priv->stuff_flag = TRUE;
	} else {
		picolanSTATE _tmp2_;
		if (self->priv->stuff_flag == FALSE) {
			gboolean _tmp1_ = FALSE;
			if (((gint) b) == 0xAB) {
				_tmp1_ = TRUE;
			} else {
				_tmp1_ = ((gint) b) == 0xAC;
			}
			if (_tmp1_) {
				self->priv->state = PICOLAN_STATE_START;
			}
		}
		self->priv->stuff_flag = FALSE;
		_tmp2_ = self->priv->state;
		switch (_tmp2_) {
			case PICOLAN_STATE_START:
			{
				if (((gint) b) == 0xAB) {
					GeeArrayList* _tmp3_;
					self->priv->state = PICOLAN_STATE_ID;
					_tmp3_ = gee_array_list_new (G_TYPE_UCHAR, NULL, NULL, NULL, NULL, NULL);
					_g_object_unref0 (self->priv->data);
					self->priv->data = _tmp3_;
				}
				break;
			}
			case PICOLAN_STATE_ID:
			{
				GeeArrayList* _tmp4_;
				self->priv->id = b;
				self->priv->state = PICOLAN_STATE_SIZE;
				_tmp4_ = self->priv->data;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp4_, (gpointer) ((guintptr) b));
				break;
			}
			case PICOLAN_STATE_SIZE:
			{
				GeeArrayList* _tmp5_;
				self->priv->size = b;
				self->priv->state = PICOLAN_STATE_DATA;
				_tmp5_ = self->priv->data;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp5_, (gpointer) ((guintptr) b));
				break;
			}
			case PICOLAN_STATE_DATA:
			{
				GeeArrayList* _tmp6_;
				gboolean _tmp7_ = FALSE;
				GeeArrayList* _tmp8_;
				gint _tmp9_;
				gint _tmp10_;
				_tmp6_ = self->priv->data;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp6_, (gpointer) ((guintptr) b));
				_tmp8_ = self->priv->data;
				_tmp9_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp8_);
				_tmp10_ = _tmp9_;
				if ((_tmp10_ - 2) >= ((gint) self->priv->size)) {
					_tmp7_ = TRUE;
				} else {
					GeeArrayList* _tmp11_;
					gint _tmp12_;
					gint _tmp13_;
					_tmp11_ = self->priv->data;
					_tmp12_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp11_);
					_tmp13_ = _tmp12_;
					_tmp7_ = _tmp13_ >= 255;
				}
				if (_tmp7_) {
					self->priv->state = PICOLAN_STATE_CHECK1;
				}
				break;
			}
			case PICOLAN_STATE_CHECK1:
			{
				self->priv->check1 = b;
				self->priv->state = PICOLAN_STATE_CHECK2;
				break;
			}
			case PICOLAN_STATE_CHECK2:
			{
				gint cs1 = 0;
				gint cs2 = 0;
				GeeArrayList* _tmp14_;
				gint _tmp15_ = 0;
				gint _tmp16_ = 0;
				gboolean _tmp17_ = FALSE;
				self->priv->check2 = b;
				self->priv->state = PICOLAN_STATE_START;
				_tmp14_ = self->priv->data;
				picolan_make_checksum (_tmp14_, &_tmp15_, &_tmp16_);
				cs1 = _tmp15_;
				cs2 = _tmp16_;
				if (cs1 == ((gint) self->priv->check1)) {
					_tmp17_ = cs2 == ((gint) self->priv->check2);
				} else {
					_tmp17_ = FALSE;
				}
				if (_tmp17_) {
					GeeArrayList* _tmp18_;
					GeeArrayList* _tmp19_;
					_tmp18_ = self->priv->data;
					gee_abstract_list_remove_at ((GeeAbstractList*) _tmp18_, 0);
					_tmp19_ = self->priv->data;
					gee_abstract_list_remove_at ((GeeAbstractList*) _tmp19_, 0);
					picolan_parser_parse_packet (self);
				}
				break;
			}
			default:
			break;
		}
	}
}

static void
picolan_parser_parse_packet (picolanParser* self)
{
	g_return_if_fail (self != NULL);
	switch (self->priv->id) {
		case PICOLAN_PACKET_PING_ECHO:
		{
			GeeArrayList* _tmp0_;
			gpointer _tmp1_;
			GeeArrayList* _tmp2_;
			gpointer _tmp3_;
			GeeArrayList* _tmp4_;
			gpointer _tmp5_;
			GeeArrayList* _tmp6_;
			gpointer _tmp7_;
			_tmp0_ = self->priv->data;
			_tmp1_ = gee_abstract_list_get ((GeeAbstractList*) _tmp0_, 1);
			_tmp2_ = self->priv->data;
			_tmp3_ = gee_abstract_list_get ((GeeAbstractList*) _tmp2_, 2);
			_tmp4_ = self->priv->data;
			_tmp5_ = gee_abstract_list_get ((GeeAbstractList*) _tmp4_, 3);
			_tmp6_ = self->priv->data;
			_tmp7_ = gee_abstract_list_get ((GeeAbstractList*) _tmp6_, 4);
			g_signal_emit (self, picolan_parser_signals[PICOLAN_PARSER_ON_PING_ECHO_SIGNAL], 0, (guint8) ((guintptr) _tmp1_), (guint8) ((guintptr) _tmp3_), (guint8) ((guintptr) _tmp5_), (guint8) ((guintptr) _tmp7_));
			break;
		}
		case PICOLAN_PACKET_PING:
		{
			GeeArrayList* _tmp8_;
			gpointer _tmp9_;
			GeeArrayList* _tmp10_;
			gpointer _tmp11_;
			GeeArrayList* _tmp12_;
			gpointer _tmp13_;
			GeeArrayList* _tmp14_;
			gpointer _tmp15_;
			_tmp8_ = self->priv->data;
			_tmp9_ = gee_abstract_list_get ((GeeAbstractList*) _tmp8_, 1);
			_tmp10_ = self->priv->data;
			_tmp11_ = gee_abstract_list_get ((GeeAbstractList*) _tmp10_, 2);
			_tmp12_ = self->priv->data;
			_tmp13_ = gee_abstract_list_get ((GeeAbstractList*) _tmp12_, 3);
			_tmp14_ = self->priv->data;
			_tmp15_ = gee_abstract_list_get ((GeeAbstractList*) _tmp14_, 4);
			g_signal_emit (self, picolan_parser_signals[PICOLAN_PARSER_ON_PING_SIGNAL], 0, (guint8) ((guintptr) _tmp9_), (guint8) ((guintptr) _tmp11_), (guint8) ((guintptr) _tmp13_), (guint8) ((guintptr) _tmp15_));
			break;
		}
		case PICOLAN_PACKET_GET_ADDR_LIST:
		{
			g_signal_emit (self, picolan_parser_signals[PICOLAN_PARSER_ON_GET_ADDR_LIST_SIGNAL], 0);
			break;
		}
		case PICOLAN_PACKET_DATAGRAM:
		{
			GeeArrayList* payload = NULL;
			GeeArrayList* _tmp16_;
			GeeArrayList* _tmp25_;
			gpointer _tmp26_;
			GeeArrayList* _tmp27_;
			gpointer _tmp28_;
			GeeArrayList* _tmp29_;
			gpointer _tmp30_;
			GeeArrayList* _tmp31_;
			_tmp16_ = gee_array_list_new (G_TYPE_UCHAR, NULL, NULL, NULL, NULL, NULL);
			payload = _tmp16_;
			{
				gint i = 0;
				i = 4;
				{
					gboolean _tmp17_ = FALSE;
					_tmp17_ = TRUE;
					while (TRUE) {
						GeeArrayList* _tmp19_;
						gint _tmp20_;
						gint _tmp21_;
						GeeArrayList* _tmp22_;
						GeeArrayList* _tmp23_;
						gpointer _tmp24_;
						if (!_tmp17_) {
							gint _tmp18_;
							_tmp18_ = i;
							i = _tmp18_ + 1;
						}
						_tmp17_ = FALSE;
						_tmp19_ = self->priv->data;
						_tmp20_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp19_);
						_tmp21_ = _tmp20_;
						if (!(i < _tmp21_)) {
							break;
						}
						_tmp22_ = payload;
						_tmp23_ = self->priv->data;
						_tmp24_ = gee_abstract_list_get ((GeeAbstractList*) _tmp23_, i);
						gee_abstract_collection_add ((GeeAbstractCollection*) _tmp22_, (gpointer) ((guintptr) ((guint8) ((guintptr) _tmp24_))));
					}
				}
			}
			_tmp25_ = self->priv->data;
			_tmp26_ = gee_abstract_list_get ((GeeAbstractList*) _tmp25_, 1);
			_tmp27_ = self->priv->data;
			_tmp28_ = gee_abstract_list_get ((GeeAbstractList*) _tmp27_, 2);
			_tmp29_ = self->priv->data;
			_tmp30_ = gee_abstract_list_get ((GeeAbstractList*) _tmp29_, 3);
			_tmp31_ = payload;
			g_signal_emit (self, picolan_parser_signals[PICOLAN_PARSER_ON_DATAGRAM_SIGNAL], 0, (guint8) ((guintptr) _tmp26_), (guint8) ((guintptr) _tmp28_), (guint8) ((guintptr) _tmp30_), _tmp31_);
			_g_object_unref0 (payload);
			break;
		}
		default:
		break;
	}
}

static void
g_cclosure_user_marshal_VOID__UCHAR_UCHAR_UCHAR_UCHAR (GClosure * closure,
                                                       GValue * return_value,
                                                       guint n_param_values,
                                                       const GValue * param_values,
                                                       gpointer invocation_hint,
                                                       gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__UCHAR_UCHAR_UCHAR_UCHAR) (gpointer data1, guint8 arg_1, guint8 arg_2, guint8 arg_3, guint8 arg_4, gpointer data2);
	register GMarshalFunc_VOID__UCHAR_UCHAR_UCHAR_UCHAR callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 5);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__UCHAR_UCHAR_UCHAR_UCHAR) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_uchar (param_values + 1), g_value_get_uchar (param_values + 2), g_value_get_uchar (param_values + 3), g_value_get_uchar (param_values + 4), data2);
}

static void
g_cclosure_user_marshal_VOID__UCHAR_UCHAR_UCHAR_OBJECT (GClosure * closure,
                                                        GValue * return_value,
                                                        guint n_param_values,
                                                        const GValue * param_values,
                                                        gpointer invocation_hint,
                                                        gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__UCHAR_UCHAR_UCHAR_OBJECT) (gpointer data1, guint8 arg_1, guint8 arg_2, guint8 arg_3, gpointer arg_4, gpointer data2);
	register GMarshalFunc_VOID__UCHAR_UCHAR_UCHAR_OBJECT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 5);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__UCHAR_UCHAR_UCHAR_OBJECT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_uchar (param_values + 1), g_value_get_uchar (param_values + 2), g_value_get_uchar (param_values + 3), g_value_get_object (param_values + 4), data2);
}

static void
picolan_parser_class_init (picolanParserClass * klass,
                           gpointer klass_data)
{
	picolan_parser_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &picolanParser_private_offset);
	G_OBJECT_CLASS (klass)->finalize = picolan_parser_finalize;
	picolan_parser_signals[PICOLAN_PARSER_ON_GET_ADDR_LIST_SIGNAL] = g_signal_new ("on-get-addr-list", PICOLAN_TYPE_PARSER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	picolan_parser_signals[PICOLAN_PARSER_ON_ADDR_SIGNAL] = g_signal_new ("on-addr", PICOLAN_TYPE_PARSER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__UCHAR, G_TYPE_NONE, 1, G_TYPE_UCHAR);
	picolan_parser_signals[PICOLAN_PARSER_ON_PING_SIGNAL] = g_signal_new ("on-ping", PICOLAN_TYPE_PARSER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__UCHAR_UCHAR_UCHAR_UCHAR, G_TYPE_NONE, 4, G_TYPE_UCHAR, G_TYPE_UCHAR, G_TYPE_UCHAR, G_TYPE_UCHAR);
	picolan_parser_signals[PICOLAN_PARSER_ON_PING_ECHO_SIGNAL] = g_signal_new ("on-ping-echo", PICOLAN_TYPE_PARSER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__UCHAR_UCHAR_UCHAR_UCHAR, G_TYPE_NONE, 4, G_TYPE_UCHAR, G_TYPE_UCHAR, G_TYPE_UCHAR, G_TYPE_UCHAR);
	picolan_parser_signals[PICOLAN_PARSER_ON_DATAGRAM_SIGNAL] = g_signal_new ("on-datagram", PICOLAN_TYPE_PARSER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__UCHAR_UCHAR_UCHAR_OBJECT, G_TYPE_NONE, 4, G_TYPE_UCHAR, G_TYPE_UCHAR, G_TYPE_UCHAR, GEE_TYPE_ARRAY_LIST);
}

static void
picolan_parser_instance_init (picolanParser * self,
                              gpointer klass)
{
	self->priv = picolan_parser_get_instance_private (self);
	self->priv->stuff_flag = FALSE;
}

static void
picolan_parser_finalize (GObject * obj)
{
	picolanParser * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PICOLAN_TYPE_PARSER, picolanParser);
	_g_object_unref0 (self->priv->data);
	G_OBJECT_CLASS (picolan_parser_parent_class)->finalize (obj);
}

GType
picolan_parser_get_type (void)
{
	static volatile gsize picolan_parser_type_id__volatile = 0;
	if (g_once_init_enter (&picolan_parser_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (picolanParserClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) picolan_parser_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (picolanParser), 0, (GInstanceInitFunc) picolan_parser_instance_init, NULL };
		GType picolan_parser_type_id;
		picolan_parser_type_id = g_type_register_static (G_TYPE_OBJECT, "picolanParser", &g_define_type_info, 0);
		picolanParser_private_offset = g_type_add_instance_private (picolan_parser_type_id, sizeof (picolanParserPrivate));
		g_once_init_leave (&picolan_parser_type_id__volatile, picolan_parser_type_id);
	}
	return picolan_parser_type_id__volatile;
}

GQuark
picolan_picolan_error_quark (void)
{
	return g_quark_from_static_string ("picolan-picolan-error-quark");
}

static inline gpointer
picolan_interface_get_instance_private (picolanInterface* self)
{
	return G_STRUCT_MEMBER_P (self, picolanInterface_private_offset);
}

static void
__lambda4_ (picolanInterface* self,
            guint8 src,
            guint8 dest,
            guint8 p1,
            guint8 p2)
{
	GeeArrayList* msg = NULL;
	GeeArrayList* _tmp0_;
	GeeArrayList* _tmp1_;
	GeeArrayList* _tmp2_;
	GeeArrayList* _tmp3_;
	GeeArrayList* _tmp4_;
	GeeArrayList* _tmp5_;
	GeeArrayList* _tmp6_;
	GeeArrayList* _tmp7_;
	gint cs1 = 0;
	gint cs2 = 0;
	GeeArrayList* _tmp8_;
	gint _tmp9_ = 0;
	gint _tmp10_ = 0;
	GeeArrayList* _tmp11_;
	GeeArrayList* _tmp12_;
	GeeArrayList* _tmp13_;
	GeeArrayList* _tmp14_;
	GeeArrayList* _tmp15_;
	GeeArrayList* _tmp16_;
	GError* _inner_error0_ = NULL;
	_tmp0_ = gee_array_list_new (G_TYPE_UCHAR, NULL, NULL, NULL, NULL, NULL);
	msg = _tmp0_;
	_tmp1_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp1_, (gpointer) ((guintptr) ((guint8) PICOLAN_PACKET_PING_ECHO)));
	_tmp2_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp2_, (gpointer) ((guintptr) ((guint8) 5)));
	_tmp3_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp3_, (gpointer) ((guintptr) self->ttl));
	_tmp4_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp4_, (gpointer) ((guintptr) self->priv->address));
	_tmp5_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp5_, (gpointer) ((guintptr) src));
	_tmp6_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp6_, (gpointer) ((guintptr) p1));
	_tmp7_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp7_, (gpointer) ((guintptr) p2));
	_tmp8_ = msg;
	picolan_make_checksum (_tmp8_, &_tmp9_, &_tmp10_);
	cs1 = _tmp9_;
	cs2 = _tmp10_;
	_tmp11_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp11_, (gpointer) ((guintptr) ((guint8) cs1)));
	_tmp12_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp12_, (gpointer) ((guintptr) ((guint8) cs2)));
	_tmp13_ = msg;
	_tmp14_ = picolan_interface_stuff_bytes (self, _tmp13_);
	_g_object_unref0 (msg);
	msg = _tmp14_;
	_tmp15_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp15_, (gpointer) ((guintptr) ((guint8) 0xAC)));
	_tmp16_ = msg;
	gee_abstract_list_insert ((GeeAbstractList*) _tmp16_, 0, (gpointer) ((guintptr) ((guint8) 0xAB)));
	{
		GeeArrayList* _tmp17_;
		_tmp17_ = msg;
		picolan_interface_write_byte_array (self, _tmp17_, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch2_g_error;
		}
	}
	goto __finally2;
	__catch2_g_error:
	{
		GError* _error_ = NULL;
		FILE* _tmp18_;
		FILE* _tmp19_;
		GError* _tmp20_;
		const gchar* _tmp21_;
		_error_ = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp18_ = stdout;
		fprintf (_tmp18_, "Error while responding to a ping.\n");
		_tmp19_ = stdout;
		_tmp20_ = _error_;
		_tmp21_ = _tmp20_->message;
		fprintf (_tmp19_, "%s\n", _tmp21_);
		_g_error_free0 (_error_);
	}
	__finally2:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_object_unref0 (msg);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	_g_object_unref0 (msg);
}

static void
___lambda4__picolan_parser_on_ping (picolanParser* _sender,
                                    guint8 src,
                                    guint8 dest,
                                    guint8 p1,
                                    guint8 p2,
                                    gpointer self)
{
	__lambda4_ ((picolanInterface*) self, src, dest, p1, p2);
}

static void
__lambda6_ (picolanInterface* self)
{
	GError* _inner_error0_ = NULL;
	{
		picolan_interface_set_address (self, self->priv->address, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch3_g_error;
		}
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError* _error_ = NULL;
		FILE* _tmp0_;
		FILE* _tmp1_;
		GError* _tmp2_;
		const gchar* _tmp3_;
		_error_ = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp0_ = stdout;
		fprintf (_tmp0_, "Error responding to request for this address.\n");
		_tmp1_ = stdout;
		_tmp2_ = _error_;
		_tmp3_ = _tmp2_->message;
		fprintf (_tmp1_, "%s\n", _tmp3_);
		_g_error_free0 (_error_);
	}
	__finally3:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}

static void
___lambda6__picolan_parser_on_get_addr_list (picolanParser* _sender,
                                             gpointer self)
{
	__lambda6_ ((picolanInterface*) self);
}

static void
__lambda7_ (picolanInterface* self,
            guint8 src,
            guint8 dest,
            guint8 port,
            GeeArrayList* payload)
{
	g_return_if_fail (payload != NULL);
	g_signal_emit (self, picolan_interface_signals[PICOLAN_INTERFACE_ON_DATAGRAM_SIGNAL], 0, src, dest, port, payload);
}

static void
___lambda7__picolan_parser_on_datagram (picolanParser* _sender,
                                        guint8 src,
                                        guint8 dest,
                                        guint8 port,
                                        GeeArrayList* payload,
                                        gpointer self)
{
	__lambda7_ ((picolanInterface*) self, src, dest, port, payload);
}

static gboolean
__lambda8_ (picolanInterface* self)
{
	gboolean result = FALSE;
	gserialPort* _tmp0_;
	GError* _inner_error0_ = NULL;
	_tmp0_ = self->priv->port;
	if (gserial_port_is_open (_tmp0_)) {
		{
			guint _tmp1_ = 0U;
			gserialPort* _tmp2_;
			_tmp2_ = self->priv->port;
			_tmp1_ = gserial_port_available (_tmp2_, &_inner_error0_);
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				goto __catch4_g_error;
			}
			if (_tmp1_ > ((guint) 0)) {
				guint len = 0U;
				gserialPort* _tmp3_;
				GArray* bytes = NULL;
				GArray* _tmp4_;
				gserialPort* _tmp5_;
				GArray* _tmp6_ = NULL;
				_tmp3_ = self->priv->port;
				len = gserial_port_available (_tmp3_, &_inner_error0_);
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
					goto __catch4_g_error;
				}
				_tmp4_ = g_array_new (TRUE, TRUE, sizeof (gchar));
				bytes = _tmp4_;
				_tmp5_ = self->priv->port;
				gserial_port_read_bytes (_tmp5_, len, &_tmp6_, &_inner_error0_);
				_g_array_unref0 (bytes);
				bytes = _tmp6_;
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
					_g_array_unref0 (bytes);
					goto __catch4_g_error;
				}
				{
					guint i = 0U;
					i = (guint) 0;
					{
						gboolean _tmp7_ = FALSE;
						_tmp7_ = TRUE;
						while (TRUE) {
							GArray* _tmp9_;
							picolanParser* _tmp10_;
							GArray* _tmp11_;
							if (!_tmp7_) {
								guint _tmp8_;
								_tmp8_ = i;
								i = _tmp8_ + 1;
							}
							_tmp7_ = FALSE;
							_tmp9_ = bytes;
							if (!(i < _tmp9_->len)) {
								break;
							}
							_tmp10_ = self->priv->parser;
							_tmp11_ = bytes;
							picolan_parser_read (_tmp10_, (guint8) g_array_index (_tmp11_, gchar, i));
						}
					}
				}
				_g_array_unref0 (bytes);
			}
		}
		goto __finally4;
		__catch4_g_error:
		{
			GError* e = NULL;
			FILE* _tmp12_;
			GError* _tmp13_;
			const gchar* _tmp14_;
			gserialPort* _tmp15_;
			e = _inner_error0_;
			_inner_error0_ = NULL;
			_tmp12_ = stdout;
			_tmp13_ = e;
			_tmp14_ = _tmp13_->message;
			fprintf (_tmp12_, "Error in loop: %s\n", _tmp14_);
			_tmp15_ = self->priv->port;
			gserial_port_close (_tmp15_);
			g_signal_emit (self, picolan_interface_signals[PICOLAN_INTERFACE_ON_CLOSE_SIGNAL], 0);
			_g_error_free0 (e);
		}
		__finally4:
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			gboolean _tmp16_ = FALSE;
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return _tmp16_;
		}
	}
	result = TRUE;
	return result;
}

static gboolean
___lambda8__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda8_ ((picolanInterface*) self);
	return result;
}

picolanInterface*
picolan_interface_construct (GType object_type)
{
	picolanInterface * self = NULL;
	picolanParser* _tmp0_;
	GeeHashMap* _tmp1_;
	picolanParser* _tmp2_;
	picolanParser* _tmp3_;
	picolanParser* _tmp4_;
	self = (picolanInterface*) g_object_new (object_type, NULL);
	_tmp0_ = picolan_parser_new ();
	_g_object_unref0 (self->priv->parser);
	self->priv->parser = _tmp0_;
	_tmp1_ = gee_hash_map_new (G_TYPE_UCHAR, NULL, NULL, PICOLAN_TYPE_SOCKET, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->port_map);
	self->priv->port_map = _tmp1_;
	_tmp2_ = self->priv->parser;
	g_signal_connect_object (_tmp2_, "on-ping", (GCallback) ___lambda4__picolan_parser_on_ping, self, 0);
	_tmp3_ = self->priv->parser;
	g_signal_connect_object (_tmp3_, "on-get-addr-list", (GCallback) ___lambda6__picolan_parser_on_get_addr_list, self, 0);
	_tmp4_ = self->priv->parser;
	g_signal_connect_object (_tmp4_, "on-datagram", (GCallback) ___lambda7__picolan_parser_on_datagram, self, 0);
	g_timeout_add_full (1, (guint) 10, ___lambda8__gsource_func, g_object_ref (self), g_object_unref);
	return self;
}

picolanInterface*
picolan_interface_new (void)
{
	return picolan_interface_construct (PICOLAN_TYPE_INTERFACE);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static Block1Data*
block1_data_ref (Block1Data* _data1_)
{
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}

static void
block1_data_unref (void * _userdata_)
{
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		picolanInterface* self;
		self = _data1_->self;
		_g_object_unref0 (_data1_->s);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}

static void
___lambda9_ (Block1Data* _data1_)
{
	picolanInterface* self;
	GeeHashMap* _tmp0_;
	self = _data1_->self;
	_tmp0_ = self->priv->port_map;
	gee_abstract_map_unset ((GeeAbstractMap*) _tmp0_, (gpointer) ((guintptr) picolan_socket_get_port (_data1_->s)), NULL);
}

static void
____lambda9__picolan_socket_on_destroy (picolanSocket* _sender,
                                        gpointer self)
{
	___lambda9_ (self);
}

gboolean
picolan_interface_attach_socket (picolanInterface* self,
                                 picolanSocket* s)
{
	gboolean result = FALSE;
	Block1Data* _data1_;
	picolanSocket* _tmp0_;
	GeeHashMap* _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (s != NULL, FALSE);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	_tmp0_ = _g_object_ref0 (s);
	_g_object_unref0 (_data1_->s);
	_data1_->s = _tmp0_;
	_tmp1_ = self->priv->port_map;
	if (gee_abstract_map_has_key ((GeeAbstractMap*) _tmp1_, (gpointer) ((guintptr) picolan_socket_get_port (_data1_->s))) == FALSE) {
		GeeHashMap* _tmp2_;
		_tmp2_ = self->priv->port_map;
		gee_abstract_map_set ((GeeAbstractMap*) _tmp2_, (gpointer) ((guintptr) picolan_socket_get_port (_data1_->s)), _data1_->s);
		g_signal_connect_data (_data1_->s, "on-destroy", (GCallback) ____lambda9__picolan_socket_on_destroy, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
		result = TRUE;
		block1_data_unref (_data1_);
		_data1_ = NULL;
		return result;
	} else {
		result = FALSE;
		block1_data_unref (_data1_);
		_data1_ = NULL;
		return result;
	}
	block1_data_unref (_data1_);
	_data1_ = NULL;
}

gboolean
picolan_interface_open (picolanInterface* self,
                        const gchar* port_name,
                        gint baud,
                        GError** error)
{
	gboolean result = FALSE;
	gserialPort* _tmp0_;
	gserialPort* _tmp1_;
	gserialPort* _tmp2_;
	gserialPort* _tmp4_;
	GError* _inner_error0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (port_name != NULL, FALSE);
	_tmp0_ = gserial_port_new ();
	_g_object_unref0 (self->priv->port);
	self->priv->port = _tmp0_;
	_tmp1_ = self->priv->port;
	gserial_port_set_baud (_tmp1_, baud);
	_tmp2_ = self->priv->port;
	gserial_port_open (_tmp2_, port_name, &_inner_error0_);
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		gboolean _tmp3_ = FALSE;
		g_propagate_error (error, _inner_error0_);
		return _tmp3_;
	}
	_tmp4_ = self->priv->port;
	result = gserial_port_is_open (_tmp4_);
	return result;
}

void
picolan_interface_close (picolanInterface* self)
{
	gserialPort* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->port;
	gserial_port_close (_tmp0_);
	g_signal_emit (self, picolan_interface_signals[PICOLAN_INTERFACE_ON_CLOSE_SIGNAL], 0);
}

void
picolan_interface_set_address (picolanInterface* self,
                               guint8 addr,
                               GError** error)
{
	picolanAddressField* af = NULL;
	picolanAddressField* _tmp0_;
	picolanAddressField* _tmp1_;
	GeeArrayList* msg = NULL;
	GeeArrayList* _tmp2_;
	GeeArrayList* _tmp3_;
	GeeArrayList* _tmp4_;
	GeeArrayList* _tmp5_;
	gint cs1 = 0;
	gint cs2 = 0;
	GeeArrayList* _tmp14_;
	gint _tmp15_ = 0;
	gint _tmp16_ = 0;
	GeeArrayList* _tmp17_;
	GeeArrayList* _tmp18_;
	GeeArrayList* _tmp19_;
	GeeArrayList* _tmp20_;
	GeeArrayList* _tmp21_;
	GeeArrayList* _tmp22_;
	GeeArrayList* _tmp23_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	self->priv->address = addr;
	_tmp0_ = picolan_address_field_new ();
	af = _tmp0_;
	_tmp1_ = af;
	picolan_address_field_set_address (_tmp1_, addr);
	_tmp2_ = gee_array_list_new (G_TYPE_UCHAR, NULL, NULL, NULL, NULL, NULL);
	msg = _tmp2_;
	_tmp3_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp3_, (gpointer) ((guintptr) ((guint8) PICOLAN_PACKET_ADDR)));
	_tmp4_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp4_, (gpointer) ((guintptr) ((guint8) 32)));
	_tmp5_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp5_, (gpointer) ((guintptr) self->ttl));
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp6_ = FALSE;
			_tmp6_ = TRUE;
			while (TRUE) {
				GeeArrayList* _tmp8_;
				picolanAddressField* _tmp9_;
				gint _tmp10_ = 0;
				guint8* _tmp11_;
				guint8* _tmp12_;
				gint _tmp12__length1;
				guint8 _tmp13_;
				if (!_tmp6_) {
					gint _tmp7_;
					_tmp7_ = i;
					i = _tmp7_ + 1;
				}
				_tmp6_ = FALSE;
				if (!(i < 32)) {
					break;
				}
				_tmp8_ = msg;
				_tmp9_ = af;
				_tmp11_ = picolan_address_field_get_bytes (_tmp9_, &_tmp10_);
				_tmp12_ = _tmp11_;
				_tmp12__length1 = _tmp10_;
				_tmp13_ = _tmp12_[i];
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp8_, (gpointer) ((guintptr) _tmp13_));
				_tmp12_ = (g_free (_tmp12_), NULL);
			}
		}
	}
	_tmp14_ = msg;
	picolan_make_checksum (_tmp14_, &_tmp15_, &_tmp16_);
	cs1 = _tmp15_;
	cs2 = _tmp16_;
	_tmp17_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp17_, (gpointer) ((guintptr) ((guint8) cs1)));
	_tmp18_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp18_, (gpointer) ((guintptr) ((guint8) cs2)));
	_tmp19_ = msg;
	_tmp20_ = picolan_interface_stuff_bytes (self, _tmp19_);
	_g_object_unref0 (msg);
	msg = _tmp20_;
	_tmp21_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp21_, (gpointer) ((guintptr) ((guint8) 0xAC)));
	_tmp22_ = msg;
	gee_abstract_list_insert ((GeeAbstractList*) _tmp22_, 0, (gpointer) ((guintptr) ((guint8) 0xAB)));
	_tmp23_ = msg;
	picolan_interface_write_byte_array (self, _tmp23_, &_inner_error0_);
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_propagate_error (error, _inner_error0_);
		_g_object_unref0 (msg);
		_picolan_address_field_unref0 (af);
		return;
	}
	_g_object_unref0 (msg);
	_picolan_address_field_unref0 (af);
}

void
picolan_interface_send_datagram (picolanInterface* self,
                                 guint8 dest,
                                 guint8 port,
                                 GeeArrayList* data,
                                 GError** error)
{
	gint _tmp0_;
	gint _tmp1_;
	GeeArrayList* msg = NULL;
	GeeArrayList* _tmp3_;
	GeeArrayList* _tmp4_;
	GeeArrayList* _tmp5_;
	gint _tmp6_;
	gint _tmp7_;
	GeeArrayList* _tmp8_;
	GeeArrayList* _tmp9_;
	GeeArrayList* _tmp10_;
	GeeArrayList* _tmp11_;
	GeeArrayList* _tmp12_;
	gint _tmp13_;
	gint _tmp14_;
	gint cs1 = 0;
	gint cs2 = 0;
	GeeArrayList* _tmp21_;
	gint _tmp22_ = 0;
	gint _tmp23_ = 0;
	GeeArrayList* _tmp24_;
	GeeArrayList* _tmp25_;
	GeeArrayList* _tmp26_;
	GeeArrayList* _tmp27_;
	GeeArrayList* _tmp28_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (data != NULL);
	_tmp0_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) data);
	_tmp1_ = _tmp0_;
	if (_tmp1_ >= 250) {
		GError* _tmp2_;
		_tmp2_ = g_error_new_literal (PICOLAN_PICOLAN_ERROR, PICOLAN_PICOLAN_ERROR_PAYLOAD_TOO_BIG, "Payload size is greater than the maximum of 250 bytes");
		_inner_error0_ = _tmp2_;
		g_propagate_error (error, _inner_error0_);
		return;
	}
	_tmp3_ = gee_array_list_new (G_TYPE_UCHAR, NULL, NULL, NULL, NULL, NULL);
	msg = _tmp3_;
	_tmp4_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp4_, (gpointer) ((guintptr) ((guint8) PICOLAN_PACKET_DATAGRAM)));
	_tmp5_ = msg;
	_tmp6_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) data);
	_tmp7_ = _tmp6_;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp5_, (gpointer) ((guintptr) ((guint8) (_tmp7_ + 5))));
	_tmp8_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp8_, (gpointer) ((guintptr) self->ttl));
	_tmp9_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp9_, (gpointer) ((guintptr) self->priv->address));
	_tmp10_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp10_, (gpointer) ((guintptr) dest));
	_tmp11_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp11_, (gpointer) ((guintptr) port));
	_tmp12_ = msg;
	_tmp13_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) data);
	_tmp14_ = _tmp13_;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp12_, (gpointer) ((guintptr) ((guint8) _tmp14_)));
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp15_ = FALSE;
			_tmp15_ = TRUE;
			while (TRUE) {
				gint _tmp17_;
				gint _tmp18_;
				GeeArrayList* _tmp19_;
				gpointer _tmp20_;
				if (!_tmp15_) {
					gint _tmp16_;
					_tmp16_ = i;
					i = _tmp16_ + 1;
				}
				_tmp15_ = FALSE;
				_tmp17_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) data);
				_tmp18_ = _tmp17_;
				if (!(i < _tmp18_)) {
					break;
				}
				_tmp19_ = msg;
				_tmp20_ = gee_abstract_list_get ((GeeAbstractList*) data, i);
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp19_, (gpointer) ((guintptr) ((guint8) ((guintptr) _tmp20_))));
			}
		}
	}
	_tmp21_ = msg;
	picolan_make_checksum (_tmp21_, &_tmp22_, &_tmp23_);
	cs1 = _tmp22_;
	cs2 = _tmp23_;
	_tmp24_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp24_, (gpointer) ((guintptr) ((guint8) cs1)));
	_tmp25_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp25_, (gpointer) ((guintptr) ((guint8) cs2)));
	_tmp26_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp26_, (gpointer) ((guintptr) ((guint8) 0xAC)));
	_tmp27_ = msg;
	gee_abstract_list_insert ((GeeAbstractList*) _tmp27_, 0, (gpointer) ((guintptr) ((guint8) 0xAB)));
	_tmp28_ = msg;
	picolan_interface_write_byte_array (self, _tmp28_, &_inner_error0_);
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_propagate_error (error, _inner_error0_);
		_g_object_unref0 (msg);
		return;
	}
	_g_object_unref0 (msg);
}

static void
picolan_interface_ping_data_free (gpointer _data)
{
	PicolanInterfacePingData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (PicolanInterfacePingData, _data_);
}

static void
picolan_interface_ping_async_ready_wrapper (GObject *source_object,
                                            GAsyncResult *res,
                                            void *user_data)
{
	PicolanInterfacePingData* _task_data_;
	_task_data_ = g_task_get_task_data (G_TASK (res));
	if (_task_data_->_callback_ != NULL) {
		_task_data_->_callback_ (source_object, res, user_data);
	}
	_task_data_->_task_complete_ = TRUE;
}

void
picolan_interface_ping (picolanInterface* self,
                        guint8 addr,
                        guint timeout,
                        GAsyncReadyCallback _callback_,
                        gpointer _user_data_)
{
	PicolanInterfacePingData* _data_;
	picolanInterface* _tmp0_;
	_data_ = g_slice_new0 (PicolanInterfacePingData);
	_data_->_callback_ = _callback_;
	_data_->_async_result = g_task_new (G_OBJECT (self), NULL, picolan_interface_ping_async_ready_wrapper, _user_data_);
	if (_callback_ == NULL) {
		_data_->_task_complete_ = TRUE;
	}
	g_task_set_task_data (_data_->_async_result, _data_, picolan_interface_ping_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_data_->addr = addr;
	_data_->timeout = timeout;
	picolan_interface_ping_co (_data_);
}

gint
picolan_interface_ping_finish (picolanInterface* self,
                               GAsyncResult* _res_,
                               GError** error)
{
	gint result;
	PicolanInterfacePingData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), error);
	if (NULL == _data_) {
		gint _tmp0_ = 0;
		return _tmp0_;
	}
	result = _data_->result;
	return result;
}

static Block2Data*
block2_data_ref (Block2Data* _data2_)
{
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}

static void
block2_data_unref (void * _userdata_)
{
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		picolanInterface* self;
		self = _data2_->self;
		_g_timer_destroy0 (_data2_->timer);
		(_data2_->callback_target_destroy_notify == NULL) ? NULL : (_data2_->callback_target_destroy_notify (_data2_->callback_target), NULL);
		_data2_->callback = NULL;
		_data2_->callback_target = NULL;
		_data2_->callback_target_destroy_notify = NULL;
		_g_object_unref0 (self);
		g_slice_free (Block2Data, _data2_);
	}
}

static gboolean
_picolan_interface_ping_co_gsource_func (gpointer self)
{
	gboolean result;
	result = picolan_interface_ping_co (self);
	return result;
}

static void
__lambda10_ (Block2Data* _data2_,
             guint8 src,
             guint8 dest,
             guint8 p1,
             guint8 p2)
{
	picolanInterface* self;
	gboolean _tmp0_ = FALSE;
	self = _data2_->self;
	if (p1 == _data2_->payload1) {
		_tmp0_ = p2 == _data2_->payload2;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gulong micros = 0UL;
		gulong _tmp1_ = 0UL;
		GSourceFunc _tmp2_;
		gpointer _tmp2__target;
		GDestroyNotify _tmp2__target_destroy_notify;
		picolanParser* _tmp3_;
		micros = (gulong) 0;
		g_timer_elapsed (_data2_->timer, &_tmp1_);
		micros = _tmp1_;
		_data2_->ping_time = (gint) (micros / 1000);
		_tmp2_ = _data2_->callback;
		_tmp2__target = _data2_->callback_target;
		_tmp2__target_destroy_notify = _data2_->callback_target_destroy_notify;
		_data2_->callback = NULL;
		_data2_->callback_target = NULL;
		_data2_->callback_target_destroy_notify = NULL;
		g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, _tmp2_, _tmp2__target, _tmp2__target_destroy_notify);
		_tmp3_ = self->priv->parser;
		g_signal_handler_disconnect ((GObject*) _tmp3_, _data2_->handle);
		g_source_remove (_data2_->timeout_handle);
	}
}

static void
___lambda10__picolan_parser_on_ping_echo (picolanParser* _sender,
                                          guint8 src,
                                          guint8 dest,
                                          guint8 p1,
                                          guint8 p2,
                                          gpointer self)
{
	__lambda10_ (self, src, dest, p1, p2);
}

static gboolean
__lambda11_ (Block2Data* _data2_)
{
	picolanInterface* self;
	gboolean result = FALSE;
	GSourceFunc _tmp0_;
	gpointer _tmp0__target;
	GDestroyNotify _tmp0__target_destroy_notify;
	picolanParser* _tmp1_;
	self = _data2_->self;
	_tmp0_ = _data2_->callback;
	_tmp0__target = _data2_->callback_target;
	_tmp0__target_destroy_notify = _data2_->callback_target_destroy_notify;
	_data2_->callback = NULL;
	_data2_->callback_target = NULL;
	_data2_->callback_target_destroy_notify = NULL;
	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, _tmp0_, _tmp0__target, _tmp0__target_destroy_notify);
	_tmp1_ = self->priv->parser;
	g_signal_handler_disconnect ((GObject*) _tmp1_, _data2_->handle);
	result = FALSE;
	return result;
}

static gboolean
___lambda11__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda11_ (self);
	return result;
}

static gboolean
picolan_interface_ping_co (PicolanInterfacePingData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_data2_ = g_slice_new0 (Block2Data);
	_data_->_data2_->_ref_count_ = 1;
	_data_->_data2_->self = g_object_ref (_data_->self);
	_data_->_data2_->_async_data_ = _data_;
	_data_->_data2_->callback = _picolan_interface_ping_co_gsource_func;
	_data_->_data2_->callback_target = _data_;
	_data_->_data2_->callback_target_destroy_notify = NULL;
	_data_->_data2_->payload1 = (guint8) g_random_int_range ((gint32) 0, (gint32) 255);
	_data_->_data2_->payload2 = (guint8) g_random_int_range ((gint32) 0, (gint32) 255);
	_data_->_data2_->ping_time = -1;
	_data_->_tmp0_ = g_timer_new ();
	_data_->_data2_->timer = _data_->_tmp0_;
	_data_->_data2_->timeout_handle = (guint) 0;
	_data_->_data2_->handle = (gulong) 0;
	_data_->_tmp1_ = _data_->self->priv->parser;
	_data_->_tmp2_ = g_signal_connect_data (_data_->_tmp1_, "on-ping-echo", (GCallback) ___lambda10__picolan_parser_on_ping_echo, block2_data_ref (_data_->_data2_), (GClosureNotify) block2_data_unref, 0);
	_data_->_data2_->handle = _data_->_tmp2_;
	_data_->_data2_->timeout_handle = g_timeout_add_full (G_PRIORITY_DEFAULT, _data_->timeout, ___lambda11__gsource_func, block2_data_ref (_data_->_data2_), block2_data_unref);
	_data_->_tmp3_ = gee_array_list_new (G_TYPE_UCHAR, NULL, NULL, NULL, NULL, NULL);
	_data_->msg = _data_->_tmp3_;
	_data_->_tmp4_ = _data_->msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _data_->_tmp4_, (gpointer) ((guintptr) ((guint8) PICOLAN_PACKET_PING)));
	_data_->_tmp5_ = _data_->msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _data_->_tmp5_, (gpointer) ((guintptr) ((guint8) 5)));
	_data_->_tmp6_ = _data_->msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _data_->_tmp6_, (gpointer) ((guintptr) _data_->self->ttl));
	_data_->_tmp7_ = _data_->msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _data_->_tmp7_, (gpointer) ((guintptr) _data_->self->priv->address));
	_data_->_tmp8_ = _data_->msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _data_->_tmp8_, (gpointer) ((guintptr) _data_->addr));
	_data_->_tmp9_ = _data_->msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _data_->_tmp9_, (gpointer) ((guintptr) _data_->_data2_->payload1));
	_data_->_tmp10_ = _data_->msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _data_->_tmp10_, (gpointer) ((guintptr) _data_->_data2_->payload2));
	_data_->_tmp11_ = _data_->msg;
	_data_->_tmp12_ = 0;
	_data_->_tmp13_ = 0;
	picolan_make_checksum (_data_->_tmp11_, &_data_->_tmp12_, &_data_->_tmp13_);
	_data_->cs1 = _data_->_tmp12_;
	_data_->cs2 = _data_->_tmp13_;
	_data_->_tmp14_ = _data_->msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _data_->_tmp14_, (gpointer) ((guintptr) ((guint8) _data_->cs1)));
	_data_->_tmp15_ = _data_->msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _data_->_tmp15_, (gpointer) ((guintptr) ((guint8) _data_->cs2)));
	_data_->_tmp16_ = _data_->msg;
	_data_->_tmp17_ = picolan_interface_stuff_bytes (_data_->self, _data_->_tmp16_);
	_g_object_unref0 (_data_->msg);
	_data_->msg = _data_->_tmp17_;
	_data_->_tmp18_ = _data_->msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _data_->_tmp18_, (gpointer) ((guintptr) ((guint8) 0xAC)));
	_data_->_tmp19_ = _data_->msg;
	gee_abstract_list_insert ((GeeAbstractList*) _data_->_tmp19_, 0, (gpointer) ((guintptr) ((guint8) 0xAB)));
	_data_->_tmp20_ = _data_->msg;
	picolan_interface_write_byte_array (_data_->self, _data_->_tmp20_, &_data_->_inner_error0_);
	if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
		g_task_return_error (_data_->_async_result, _data_->_inner_error0_);
		_g_object_unref0 (_data_->msg);
		block2_data_unref (_data_->_data2_);
		_data_->_data2_ = NULL;
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_state_ = 1;
	return FALSE;
	_state_1:
	;
	_data_->result = _data_->_data2_->ping_time;
	_g_object_unref0 (_data_->msg);
	block2_data_unref (_data_->_data2_);
	_data_->_data2_ = NULL;
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!_data_->_task_complete_) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

void
picolan_interface_subscribe (picolanInterface* self,
                             guint8 port,
                             GError** error)
{
	GeeArrayList* msg = NULL;
	GeeArrayList* _tmp0_;
	GeeArrayList* _tmp1_;
	GeeArrayList* _tmp2_;
	GeeArrayList* _tmp3_;
	GeeArrayList* _tmp4_;
	GeeArrayList* _tmp5_;
	GeeArrayList* _tmp6_;
	gint cs1 = 0;
	gint cs2 = 0;
	GeeArrayList* _tmp7_;
	gint _tmp8_ = 0;
	gint _tmp9_ = 0;
	GeeArrayList* _tmp10_;
	GeeArrayList* _tmp11_;
	GeeArrayList* _tmp12_;
	GeeArrayList* _tmp13_;
	GeeArrayList* _tmp14_;
	GeeArrayList* _tmp15_;
	GeeArrayList* _tmp16_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = gee_array_list_new (G_TYPE_UCHAR, NULL, NULL, NULL, NULL, NULL);
	msg = _tmp0_;
	_tmp1_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp1_, (gpointer) ((guintptr) ((guint8) PICOLAN_PACKET_SUBSCRIBE)));
	_tmp2_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp2_, (gpointer) ((guintptr) ((guint8) 4)));
	_tmp3_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp3_, (gpointer) ((guintptr) self->ttl));
	_tmp4_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp4_, (gpointer) ((guintptr) port));
	_tmp5_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp5_, (gpointer) ((guintptr) self->priv->address));
	_tmp6_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp6_, (gpointer) ((guintptr) ((guint8) 1)));
	_tmp7_ = msg;
	picolan_make_checksum (_tmp7_, &_tmp8_, &_tmp9_);
	cs1 = _tmp8_;
	cs2 = _tmp9_;
	_tmp10_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp10_, (gpointer) ((guintptr) ((guint8) cs1)));
	_tmp11_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp11_, (gpointer) ((guintptr) ((guint8) cs2)));
	_tmp12_ = msg;
	_tmp13_ = picolan_interface_stuff_bytes (self, _tmp12_);
	_g_object_unref0 (msg);
	msg = _tmp13_;
	_tmp14_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp14_, (gpointer) ((guintptr) ((guint8) 0xAC)));
	_tmp15_ = msg;
	gee_abstract_list_insert ((GeeAbstractList*) _tmp15_, 0, (gpointer) ((guintptr) ((guint8) 0xAB)));
	_tmp16_ = msg;
	picolan_interface_write_byte_array (self, _tmp16_, &_inner_error0_);
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_propagate_error (error, _inner_error0_);
		_g_object_unref0 (msg);
		return;
	}
	_g_object_unref0 (msg);
}

void
picolan_interface_unsubscribe (picolanInterface* self,
                               guint8 port,
                               GError** error)
{
	GeeArrayList* msg = NULL;
	GeeArrayList* _tmp0_;
	GeeArrayList* _tmp1_;
	GeeArrayList* _tmp2_;
	GeeArrayList* _tmp3_;
	GeeArrayList* _tmp4_;
	GeeArrayList* _tmp5_;
	GeeArrayList* _tmp6_;
	gint cs1 = 0;
	gint cs2 = 0;
	GeeArrayList* _tmp7_;
	gint _tmp8_ = 0;
	gint _tmp9_ = 0;
	GeeArrayList* _tmp10_;
	GeeArrayList* _tmp11_;
	GeeArrayList* _tmp12_;
	GeeArrayList* _tmp13_;
	GeeArrayList* _tmp14_;
	GeeArrayList* _tmp15_;
	GeeArrayList* _tmp16_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = gee_array_list_new (G_TYPE_UCHAR, NULL, NULL, NULL, NULL, NULL);
	msg = _tmp0_;
	_tmp1_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp1_, (gpointer) ((guintptr) ((guint8) PICOLAN_PACKET_SUBSCRIBE)));
	_tmp2_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp2_, (gpointer) ((guintptr) ((guint8) 4)));
	_tmp3_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp3_, (gpointer) ((guintptr) self->ttl));
	_tmp4_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp4_, (gpointer) ((guintptr) port));
	_tmp5_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp5_, (gpointer) ((guintptr) self->priv->address));
	_tmp6_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp6_, (gpointer) ((guintptr) ((guint8) 0)));
	_tmp7_ = msg;
	picolan_make_checksum (_tmp7_, &_tmp8_, &_tmp9_);
	cs1 = _tmp8_;
	cs2 = _tmp9_;
	_tmp10_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp10_, (gpointer) ((guintptr) ((guint8) cs1)));
	_tmp11_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp11_, (gpointer) ((guintptr) ((guint8) cs2)));
	_tmp12_ = msg;
	_tmp13_ = picolan_interface_stuff_bytes (self, _tmp12_);
	_g_object_unref0 (msg);
	msg = _tmp13_;
	_tmp14_ = msg;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp14_, (gpointer) ((guintptr) ((guint8) 0xAC)));
	_tmp15_ = msg;
	gee_abstract_list_insert ((GeeAbstractList*) _tmp15_, 0, (gpointer) ((guintptr) ((guint8) 0xAB)));
	_tmp16_ = msg;
	picolan_interface_write_byte_array (self, _tmp16_, &_inner_error0_);
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_propagate_error (error, _inner_error0_);
		_g_object_unref0 (msg);
		return;
	}
	_g_object_unref0 (msg);
}

static GeeArrayList*
picolan_interface_stuff_bytes (picolanInterface* self,
                               GeeArrayList* bytes)
{
	GeeArrayList* result = NULL;
	GeeArrayList* ret = NULL;
	GeeArrayList* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (bytes != NULL, NULL);
	_tmp0_ = gee_array_list_new (G_TYPE_UCHAR, NULL, NULL, NULL, NULL, NULL);
	ret = _tmp0_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp1_ = FALSE;
			_tmp1_ = TRUE;
			while (TRUE) {
				gint _tmp3_;
				gint _tmp4_;
				gpointer _tmp5_;
				if (!_tmp1_) {
					gint _tmp2_;
					_tmp2_ = i;
					i = _tmp2_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp3_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) bytes);
				_tmp4_ = _tmp3_;
				if (!(i < _tmp4_)) {
					break;
				}
				_tmp5_ = gee_abstract_list_get ((GeeAbstractList*) bytes, i);
				if (((gint) ((guint8) ((guintptr) _tmp5_))) == 0xAA) {
					GeeArrayList* _tmp6_;
					GeeArrayList* _tmp7_;
					_tmp6_ = ret;
					gee_abstract_collection_add ((GeeAbstractCollection*) _tmp6_, (gpointer) ((guintptr) ((guint8) 0xAA)));
					_tmp7_ = ret;
					gee_abstract_collection_add ((GeeAbstractCollection*) _tmp7_, (gpointer) ((guintptr) ((guint8) 0xAA)));
				} else {
					gpointer _tmp8_;
					_tmp8_ = gee_abstract_list_get ((GeeAbstractList*) bytes, i);
					if (((gint) ((guint8) ((guintptr) _tmp8_))) == 0xAB) {
						GeeArrayList* _tmp9_;
						GeeArrayList* _tmp10_;
						_tmp9_ = ret;
						gee_abstract_collection_add ((GeeAbstractCollection*) _tmp9_, (gpointer) ((guintptr) ((guint8) 0xAA)));
						_tmp10_ = ret;
						gee_abstract_collection_add ((GeeAbstractCollection*) _tmp10_, (gpointer) ((guintptr) ((guint8) 0xAB)));
					} else {
						gpointer _tmp11_;
						_tmp11_ = gee_abstract_list_get ((GeeAbstractList*) bytes, i);
						if (((gint) ((guint8) ((guintptr) _tmp11_))) == 0xAC) {
							GeeArrayList* _tmp12_;
							GeeArrayList* _tmp13_;
							_tmp12_ = ret;
							gee_abstract_collection_add ((GeeAbstractCollection*) _tmp12_, (gpointer) ((guintptr) ((guint8) 0xAA)));
							_tmp13_ = ret;
							gee_abstract_collection_add ((GeeAbstractCollection*) _tmp13_, (gpointer) ((guintptr) ((guint8) 0xAC)));
						} else {
							GeeArrayList* _tmp14_;
							gpointer _tmp15_;
							_tmp14_ = ret;
							_tmp15_ = gee_abstract_list_get ((GeeAbstractList*) bytes, i);
							gee_abstract_collection_add ((GeeAbstractCollection*) _tmp14_, (gpointer) ((guintptr) ((guint8) ((guintptr) _tmp15_))));
						}
					}
				}
			}
		}
	}
	result = ret;
	return result;
}

static Block3Data*
block3_data_ref (Block3Data* _data3_)
{
	g_atomic_int_inc (&_data3_->_ref_count_);
	return _data3_;
}

static void
block3_data_unref (void * _userdata_)
{
	Block3Data* _data3_;
	_data3_ = (Block3Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data3_->_ref_count_)) {
		picolanInterface* self;
		self = _data3_->self;
		_g_array_unref0 (_data3_->arr);
		_g_object_unref0 (self);
		g_slice_free (Block3Data, _data3_);
	}
}

static gboolean
__lambda5_ (Block3Data* _data3_,
            guint8 item)
{
	picolanInterface* self;
	gboolean result = FALSE;
	gchar c = '\0';
	self = _data3_->self;
	c = (gchar) item;
	g_array_append_val (_data3_->arr, c);
	result = TRUE;
	return result;
}

static gboolean
___lambda5__gee_forall_func (gpointer g,
                             gpointer self)
{
	gboolean result;
	result = __lambda5_ (self, (guint8) ((guintptr) g));
	return result;
}

static void
picolan_interface_write_byte_array (picolanInterface* self,
                                    GeeArrayList* buf,
                                    GError** error)
{
	Block3Data* _data3_;
	GArray* _tmp0_;
	gserialPort* _tmp1_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (buf != NULL);
	_data3_ = g_slice_new0 (Block3Data);
	_data3_->_ref_count_ = 1;
	_data3_->self = g_object_ref (self);
	_tmp0_ = g_array_new (TRUE, TRUE, sizeof (gchar));
	_data3_->arr = _tmp0_;
	gee_abstract_collection_foreach ((GeeAbstractCollection*) buf, ___lambda5__gee_forall_func, _data3_);
	_tmp1_ = self->priv->port;
	gserial_port_write (_tmp1_, _data3_->arr, &_inner_error0_);
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_propagate_error (error, _inner_error0_);
		block3_data_unref (_data3_);
		_data3_ = NULL;
		return;
	}
	block3_data_unref (_data3_);
	_data3_ = NULL;
}

static void
picolan_interface_class_init (picolanInterfaceClass * klass,
                              gpointer klass_data)
{
	picolan_interface_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &picolanInterface_private_offset);
	G_OBJECT_CLASS (klass)->finalize = picolan_interface_finalize;
	picolan_interface_signals[PICOLAN_INTERFACE_ON_CLOSE_SIGNAL] = g_signal_new ("on-close", PICOLAN_TYPE_INTERFACE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	picolan_interface_signals[PICOLAN_INTERFACE_ON_DATAGRAM_SIGNAL] = g_signal_new ("on-datagram", PICOLAN_TYPE_INTERFACE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__UCHAR_UCHAR_UCHAR_OBJECT, G_TYPE_NONE, 4, G_TYPE_UCHAR, G_TYPE_UCHAR, G_TYPE_UCHAR, GEE_TYPE_ARRAY_LIST);
}

static void
picolan_interface_instance_init (picolanInterface * self,
                                 gpointer klass)
{
	self->priv = picolan_interface_get_instance_private (self);
	self->ttl = (guint8) 6;
	self->priv->address = (guint8) 0;
}

static void
picolan_interface_finalize (GObject * obj)
{
	picolanInterface * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PICOLAN_TYPE_INTERFACE, picolanInterface);
	_g_object_unref0 (self->priv->port);
	_g_object_unref0 (self->priv->parser);
	_g_object_unref0 (self->priv->port_map);
	G_OBJECT_CLASS (picolan_interface_parent_class)->finalize (obj);
}

GType
picolan_interface_get_type (void)
{
	static volatile gsize picolan_interface_type_id__volatile = 0;
	if (g_once_init_enter (&picolan_interface_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (picolanInterfaceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) picolan_interface_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (picolanInterface), 0, (GInstanceInitFunc) picolan_interface_instance_init, NULL };
		GType picolan_interface_type_id;
		picolan_interface_type_id = g_type_register_static (G_TYPE_OBJECT, "picolanInterface", &g_define_type_info, 0);
		picolanInterface_private_offset = g_type_add_instance_private (picolan_interface_type_id, sizeof (picolanInterfacePrivate));
		g_once_init_leave (&picolan_interface_type_id__volatile, picolan_interface_type_id);
	}
	return picolan_interface_type_id__volatile;
}

static Block4Data*
block4_data_ref (Block4Data* _data4_)
{
	g_atomic_int_inc (&_data4_->_ref_count_);
	return _data4_;
}

static void
block4_data_unref (void * _userdata_)
{
	Block4Data* _data4_;
	_data4_ = (Block4Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data4_->_ref_count_)) {
		_g_object_unref0 (_data4_->iface);
		g_slice_free (Block4Data, _data4_);
	}
}

static Block5Data*
block5_data_ref (Block5Data* _data5_)
{
	g_atomic_int_inc (&_data5_->_ref_count_);
	return _data5_;
}

static void
block5_data_unref (void * _userdata_)
{
	Block5Data* _data5_;
	_data5_ = (Block5Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data5_->_ref_count_)) {
		_g_object_unref0 (_data5_->dg);
		block4_data_unref (_data5_->_data4_);
		_data5_->_data4_ = NULL;
		g_slice_free (Block5Data, _data5_);
	}
}

static void
___lambda16_ (void)
{
	FILE* _tmp0_;
	_tmp0_ = stdout;
	fprintf (_tmp0_, "Port closed\n");
}

static void
____lambda16__picolan_interface_on_close (picolanInterface* _sender,
                                          gpointer self)
{
	___lambda16_ ();
}

static void
___lambda17_ (Block5Data* _data5_,
              GObject* obj,
              GAsyncResult* res)
{
	Block4Data* _data4_;
	gint time = 0;
	picolanInterface* _tmp0_;
	FILE* _tmp1_;
	GError* _inner_error0_ = NULL;
	_data4_ = _data5_->_data4_;
	g_return_if_fail (res != NULL);
	_tmp0_ = _data4_->iface;
	time = picolan_interface_ping_finish (_tmp0_, res, &_inner_error0_);
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	_tmp1_ = stdout;
	fprintf (_tmp1_, "time: %i\n", time);
}

static void
____lambda17__gasync_ready_callback (GObject* source_object,
                                     GAsyncResult* res,
                                     gpointer self)
{
	___lambda17_ (self, source_object, res);
	block5_data_unref (self);
}

static void
___lambda18_ (GeeArrayList* data)
{
	FILE* _tmp0_;
	FILE* _tmp7_;
	g_return_if_fail (data != NULL);
	_tmp0_ = stdout;
	fprintf (_tmp0_, "got some data\n");
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp1_ = FALSE;
			_tmp1_ = TRUE;
			while (TRUE) {
				gint _tmp3_;
				gint _tmp4_;
				FILE* _tmp5_;
				gpointer _tmp6_;
				if (!_tmp1_) {
					gint _tmp2_;
					_tmp2_ = i;
					i = _tmp2_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp3_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) data);
				_tmp4_ = _tmp3_;
				if (!(i < _tmp4_)) {
					break;
				}
				_tmp5_ = stdout;
				_tmp6_ = gee_abstract_list_get ((GeeAbstractList*) data, i);
				fprintf (_tmp5_, "%i ", (gint) ((guint8) ((guintptr) _tmp6_)));
			}
		}
	}
	_tmp7_ = stdout;
	fprintf (_tmp7_, "\n");
}

static void
____lambda18__picolan_socket_on_data (picolanSocket* _sender,
                                      GeeArrayList* data,
                                      gpointer self)
{
	___lambda18_ (data);
}

static gboolean
___lambda19_ (Block5Data* _data5_)
{
	Block4Data* _data4_;
	gboolean result = FALSE;
	picolanDatagram* _tmp0_;
	GError* _inner_error0_ = NULL;
	_data4_ = _data5_->_data4_;
	_tmp0_ = _data5_->dg;
	picolan_datagram_send_string (_tmp0_, (guint8) 1, (guint8) 20, "Hello world!!", &_inner_error0_);
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		gboolean _tmp1_ = FALSE;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return _tmp1_;
	}
	result = TRUE;
	return result;
}

static gboolean
____lambda19__gsource_func (gpointer self)
{
	gboolean result;
	result = ___lambda19_ (self);
	return result;
}

gint
_vala_main (void)
{
	gint result = 0;
	Block4Data* _data4_;
	picolanInterface* _tmp0_;
	GMainLoop* loop = NULL;
	GMainLoop* _tmp14_;
	GError* _inner_error0_ = NULL;
	_data4_ = g_slice_new0 (Block4Data);
	_data4_->_ref_count_ = 1;
	_tmp0_ = picolan_interface_new ();
	_data4_->iface = _tmp0_;
	{
		Block5Data* _data5_;
		picolanInterface* _tmp1_;
		picolanInterface* _tmp2_;
		picolanInterface* _tmp3_;
		picolanInterface* _tmp4_;
		picolanDatagram* _tmp5_;
		picolanDatagram* _tmp6_;
		picolanInterface* _tmp7_;
		picolanDatagram* _tmp8_;
		_data5_ = g_slice_new0 (Block5Data);
		_data5_->_ref_count_ = 1;
		_data5_->_data4_ = block4_data_ref (_data4_);
		_tmp1_ = _data4_->iface;
		picolan_interface_open (_tmp1_, "/dev/pts/4", 1000000, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			block5_data_unref (_data5_);
			_data5_ = NULL;
			goto __catch5_g_error;
		}
		_tmp2_ = _data4_->iface;
		g_signal_connect (_tmp2_, "on-close", (GCallback) ____lambda16__picolan_interface_on_close, NULL);
		_tmp3_ = _data4_->iface;
		picolan_interface_set_address (_tmp3_, (guint8) 6, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			block5_data_unref (_data5_);
			_data5_ = NULL;
			goto __catch5_g_error;
		}
		_tmp4_ = _data4_->iface;
		picolan_interface_ping (_tmp4_, (guint8) 1, (guint) 1000, ____lambda17__gasync_ready_callback, block5_data_ref (_data5_));
		_tmp5_ = picolan_datagram_new ((guint8) 80);
		_data5_->dg = _tmp5_;
		_tmp6_ = _data5_->dg;
		_tmp7_ = _data4_->iface;
		picolan_socket_bind ((picolanSocket*) _tmp6_, _tmp7_);
		_tmp8_ = _data5_->dg;
		g_signal_connect ((picolanSocket*) _tmp8_, "on-data", (GCallback) ____lambda18__picolan_socket_on_data, NULL);
		g_timeout_add_full (1, (guint) 1000, ____lambda19__gsource_func, block5_data_ref (_data5_), block5_data_unref);
		block5_data_unref (_data5_);
		_data5_ = NULL;
	}
	goto __finally5;
	__catch5_g_error:
	{
		GError* _error_ = NULL;
		FILE* _tmp9_;
		FILE* _tmp10_;
		GError* _tmp11_;
		const gchar* _tmp12_;
		_error_ = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp9_ = stdout;
		fprintf (_tmp9_, "Error caught\n");
		_tmp10_ = stdout;
		_tmp11_ = _error_;
		_tmp12_ = _tmp11_->message;
		fprintf (_tmp10_, "Error: %s\n", _tmp12_);
		_g_error_free0 (_error_);
	}
	__finally5:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		gint _tmp13_ = -1;
		block4_data_unref (_data4_);
		_data4_ = NULL;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return _tmp13_;
	}
	_tmp14_ = g_main_loop_new (NULL, FALSE);
	loop = _tmp14_;
	g_main_loop_run (loop);
	result = 0;
	_g_main_loop_unref0 (loop);
	block4_data_unref (_data4_);
	_data4_ = NULL;
	return result;
}

int
main (int argc,
      char ** argv)
{
	return _vala_main ();
}

