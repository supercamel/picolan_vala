/* interface.c generated by valac 0.44.3, the Vala compiler
 * generated from interface.vala, do not modify */

#include <glib-object.h>
#include <glib.h>
#include <gserial.h>
#include <stdio.h>
#include <gio/gio.h>

typedef enum  {
	PICOLAN_PACKET_INVALID,
	PICOLAN_PACKET_GET_ADDR_LIST,
	PICOLAN_PACKET_ADDR,
	PICOLAN_PACKET_PING,
	PICOLAN_PACKET_PING_ECHO,
	PICOLAN_PACKET_DATAGRAM,
	PICOLAN_PACKET_SUBSCRIBE,
	PICOLAN_PACKET_NULL
} picolanPACKET;

#define PICOLAN_TYPE_PACKET (picolan_packet_get_type ())
typedef enum  {
	PICOLAN_STATE_START,
	PICOLAN_STATE_ID,
	PICOLAN_STATE_SIZE,
	PICOLAN_STATE_DATA,
	PICOLAN_STATE_CHECK1,
	PICOLAN_STATE_CHECK2
} picolanSTATE;

#define PICOLAN_TYPE_STATE (picolan_state_get_type ())

#define PICOLAN_TYPE_PORT_MAP (picolan_port_map_get_type ())
#define PICOLAN_PORT_MAP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PICOLAN_TYPE_PORT_MAP, picolanPortMap))
#define PICOLAN_PORT_MAP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PICOLAN_TYPE_PORT_MAP, picolanPortMapClass))
#define PICOLAN_IS_PORT_MAP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PICOLAN_TYPE_PORT_MAP))
#define PICOLAN_IS_PORT_MAP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PICOLAN_TYPE_PORT_MAP))
#define PICOLAN_PORT_MAP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PICOLAN_TYPE_PORT_MAP, picolanPortMapClass))

typedef struct _picolanPortMap picolanPortMap;
typedef struct _picolanPortMapClass picolanPortMapClass;
typedef struct _picolanPortMapPrivate picolanPortMapPrivate;

#define PICOLAN_TYPE_SOCKET (picolan_socket_get_type ())
#define PICOLAN_SOCKET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PICOLAN_TYPE_SOCKET, picolanSocket))
#define PICOLAN_IS_SOCKET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PICOLAN_TYPE_SOCKET))
#define PICOLAN_SOCKET_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), PICOLAN_TYPE_SOCKET, picolanSocketIface))

typedef struct _picolanSocket picolanSocket;
typedef struct _picolanSocketIface picolanSocketIface;

#define PICOLAN_TYPE_INTERFACE (picolan_interface_get_type ())
#define PICOLAN_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PICOLAN_TYPE_INTERFACE, picolanInterface))
#define PICOLAN_INTERFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PICOLAN_TYPE_INTERFACE, picolanInterfaceClass))
#define PICOLAN_IS_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PICOLAN_TYPE_INTERFACE))
#define PICOLAN_IS_INTERFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PICOLAN_TYPE_INTERFACE))
#define PICOLAN_INTERFACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PICOLAN_TYPE_INTERFACE, picolanInterfaceClass))

typedef struct _picolanInterface picolanInterface;
typedef struct _picolanInterfaceClass picolanInterfaceClass;
enum  {
	PICOLAN_PORT_MAP_0_PROPERTY,
	PICOLAN_PORT_MAP_NUM_PROPERTIES
};
static GParamSpec* picolan_port_map_properties[PICOLAN_PORT_MAP_NUM_PROPERTIES];

#define PICOLAN_TYPE_PARSER (picolan_parser_get_type ())
#define PICOLAN_PARSER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PICOLAN_TYPE_PARSER, picolanParser))
#define PICOLAN_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PICOLAN_TYPE_PARSER, picolanParserClass))
#define PICOLAN_IS_PARSER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PICOLAN_TYPE_PARSER))
#define PICOLAN_IS_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PICOLAN_TYPE_PARSER))
#define PICOLAN_PARSER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PICOLAN_TYPE_PARSER, picolanParserClass))

typedef struct _picolanParser picolanParser;
typedef struct _picolanParserClass picolanParserClass;
typedef struct _picolanParserPrivate picolanParserPrivate;
enum  {
	PICOLAN_PARSER_0_PROPERTY,
	PICOLAN_PARSER_NUM_PROPERTIES
};
static GParamSpec* picolan_parser_properties[PICOLAN_PARSER_NUM_PROPERTIES];
enum  {
	PICOLAN_PARSER_ON_GET_ADDR_LIST_SIGNAL,
	PICOLAN_PARSER_ON_ADDR_SIGNAL,
	PICOLAN_PARSER_ON_PING_SIGNAL,
	PICOLAN_PARSER_ON_PING_ECHO_SIGNAL,
	PICOLAN_PARSER_ON_DATAGRAM_SIGNAL,
	PICOLAN_PARSER_NUM_SIGNALS
};
static guint picolan_parser_signals[PICOLAN_PARSER_NUM_SIGNALS] = {0};
typedef struct _picolanInterfacePrivate picolanInterfacePrivate;
enum  {
	PICOLAN_INTERFACE_0_PROPERTY,
	PICOLAN_INTERFACE_NUM_PROPERTIES
};
static GParamSpec* picolan_interface_properties[PICOLAN_INTERFACE_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_array_unref0(var) ((var == NULL) ? NULL : (var = (g_array_unref (var), NULL)))
typedef struct _Block1Data Block1Data;

#define PICOLAN_TYPE_ADDRESS_FIELD (picolan_address_field_get_type ())
#define PICOLAN_ADDRESS_FIELD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PICOLAN_TYPE_ADDRESS_FIELD, picolanAddressField))
#define PICOLAN_ADDRESS_FIELD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PICOLAN_TYPE_ADDRESS_FIELD, picolanAddressFieldClass))
#define PICOLAN_IS_ADDRESS_FIELD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PICOLAN_TYPE_ADDRESS_FIELD))
#define PICOLAN_IS_ADDRESS_FIELD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PICOLAN_TYPE_ADDRESS_FIELD))
#define PICOLAN_ADDRESS_FIELD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PICOLAN_TYPE_ADDRESS_FIELD, picolanAddressFieldClass))

typedef struct _picolanAddressField picolanAddressField;
typedef struct _picolanAddressFieldClass picolanAddressFieldClass;
#define _picolan_address_field_unref0(var) ((var == NULL) ? NULL : (var = (picolan_address_field_unref (var), NULL)))
typedef struct _Block2Data Block2Data;
#define _g_timer_destroy0(var) ((var == NULL) ? NULL : (var = (g_timer_destroy (var), NULL)))
typedef struct _PicolanInterfacePingData PicolanInterfacePingData;
enum  {
	PICOLAN_INTERFACE_ON_CLOSE_SIGNAL,
	PICOLAN_INTERFACE_ON_DATAGRAM_SIGNAL,
	PICOLAN_INTERFACE_NUM_SIGNALS
};
static guint picolan_interface_signals[PICOLAN_INTERFACE_NUM_SIGNALS] = {0};
typedef struct _Block3Data Block3Data;

#define PICOLAN_TYPE_DATAGRAM (picolan_datagram_get_type ())
#define PICOLAN_DATAGRAM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PICOLAN_TYPE_DATAGRAM, picolanDatagram))
#define PICOLAN_DATAGRAM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PICOLAN_TYPE_DATAGRAM, picolanDatagramClass))
#define PICOLAN_IS_DATAGRAM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PICOLAN_TYPE_DATAGRAM))
#define PICOLAN_IS_DATAGRAM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PICOLAN_TYPE_DATAGRAM))
#define PICOLAN_DATAGRAM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PICOLAN_TYPE_DATAGRAM, picolanDatagramClass))

typedef struct _picolanDatagram picolanDatagram;
typedef struct _picolanDatagramClass picolanDatagramClass;
typedef struct _Block4Data Block4Data;
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))

struct _picolanPortMap {
	GObject parent_instance;
	picolanPortMapPrivate * priv;
};

struct _picolanPortMapClass {
	GObjectClass parent_class;
};

struct _picolanSocketIface {
	GTypeInterface parent_iface;
	guint8 (*get_port) (picolanSocket* self);
	void (*bind) (picolanSocket* self, picolanInterface* iface);
};

struct _picolanPortMapPrivate {
	GList* map;
};

struct _picolanParser {
	GObject parent_instance;
	picolanParserPrivate * priv;
};

struct _picolanParserClass {
	GObjectClass parent_class;
};

struct _picolanParserPrivate {
	GList* data;
	guint8 id;
	guint8 size;
	picolanSTATE state;
	guint8 check1;
	guint8 check2;
	gboolean stuff_flag;
};

typedef enum  {
	PICOLAN_PICOLAN_ERROR_COMS_FAULT,
	PICOLAN_PICOLAN_ERROR_PAYLOAD_TOO_BIG
} picolanPicolanError;
#define PICOLAN_PICOLAN_ERROR picolan_picolan_error_quark ()
struct _picolanInterface {
	GObject parent_instance;
	picolanInterfacePrivate * priv;
	guint8 ttl;
};

struct _picolanInterfaceClass {
	GObjectClass parent_class;
};

struct _picolanInterfacePrivate {
	guint8 address;
	gserialPort* port;
	picolanParser* parser;
	picolanPortMap* port_map;
};

struct _Block1Data {
	int _ref_count_;
	picolanInterface* self;
	picolanSocket* s;
};

struct _Block2Data {
	int _ref_count_;
	picolanInterface* self;
	GSourceFunc callback;
	gpointer callback_target;
	GDestroyNotify callback_target_destroy_notify;
	guint8 payload1;
	guint8 payload2;
	gint ping_time;
	GTimer* timer;
	guint timeout_handle;
	gulong handle;
	gpointer _async_data_;
};

struct _PicolanInterfacePingData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GAsyncReadyCallback _callback_;
	gboolean _task_complete_;
	picolanInterface* self;
	guint8 addr;
	guint timeout;
	gint result;
	Block2Data* _data2_;
	GTimer* _tmp0_;
	picolanParser* _tmp1_;
	gulong _tmp2_;
	GList* msg;
	gint cs1;
	gint cs2;
	GList* _tmp3_;
	gint _tmp4_;
	gint _tmp5_;
	GList* _tmp6_;
	GList* _tmp7_;
	GList* _tmp8_;
};

struct _Block3Data {
	int _ref_count_;
	picolanInterface* iface;
};

struct _Block4Data {
	int _ref_count_;
	Block3Data * _data3_;
	picolanDatagram* dg;
};

static gint picolanPortMap_private_offset;
static gpointer picolan_port_map_parent_class = NULL;
static gint picolanParser_private_offset;
static gpointer picolan_parser_parent_class = NULL;
static gint picolanInterface_private_offset;
static gpointer picolan_interface_parent_class = NULL;

GType picolan_packet_get_type (void) G_GNUC_CONST;
GType picolan_state_get_type (void) G_GNUC_CONST;
void picolan_make_checksum (GList* bytes,
                            gint* sum1,
                            gint* sum2);
GType picolan_port_map_get_type (void) G_GNUC_CONST;
GType picolan_interface_get_type (void) G_GNUC_CONST;
GType picolan_socket_get_type (void) G_GNUC_CONST;
static void _g_object_unref0_ (gpointer var);
static inline void _g_list_free__g_object_unref0_ (GList* self);
picolanPortMap* picolan_port_map_new (void);
picolanPortMap* picolan_port_map_construct (GType object_type);
void picolan_port_map_add (picolanPortMap* self,
                           picolanSocket* socket);
void picolan_port_map_remove (picolanPortMap* self,
                              picolanSocket* socket);
gboolean picolan_port_map_contains (picolanPortMap* self,
                                    picolanSocket* socket);
guint8 picolan_socket_get_port (picolanSocket* self);
static void picolan_port_map_finalize (GObject * obj);
GType picolan_parser_get_type (void) G_GNUC_CONST;
picolanParser* picolan_parser_new (void);
picolanParser* picolan_parser_construct (GType object_type);
void picolan_parser_read (picolanParser* self,
                          guint8 b);
static void picolan_parser_parse_packet (picolanParser* self);
static void g_cclosure_user_marshal_VOID__UCHAR_UCHAR_UCHAR_UCHAR (GClosure * closure,
                                                            GValue * return_value,
                                                            guint n_param_values,
                                                            const GValue * param_values,
                                                            gpointer invocation_hint,
                                                            gpointer marshal_data);
static void g_cclosure_user_marshal_VOID__UCHAR_UCHAR_UCHAR_POINTER (GClosure * closure,
                                                              GValue * return_value,
                                                              guint n_param_values,
                                                              const GValue * param_values,
                                                              gpointer invocation_hint,
                                                              gpointer marshal_data);
static void picolan_parser_finalize (GObject * obj);
GQuark picolan_picolan_error_quark (void);
picolanInterface* picolan_interface_new (void);
picolanInterface* picolan_interface_construct (GType object_type);
static void __lambda4_ (picolanInterface* self,
                 guint8 src,
                 guint8 dest,
                 guint8 p1,
                 guint8 p2);
static GList* picolan_interface_stuff_bytes (picolanInterface* self,
                                      GList* bytes);
static void picolan_interface_write_list (picolanInterface* self,
                                   GList* bytes);
static void ___lambda4__picolan_parser_on_ping (picolanParser* _sender,
                                         guint8 src,
                                         guint8 dest,
                                         guint8 p1,
                                         guint8 p2,
                                         gpointer self);
static void __lambda5_ (picolanInterface* self);
void picolan_interface_set_address (picolanInterface* self,
                                    guint8 addr,
                                    GError** error);
static void ___lambda5__picolan_parser_on_get_addr_list (picolanParser* _sender,
                                                  gpointer self);
static void __lambda6_ (picolanInterface* self,
                 guint8 src,
                 guint8 dest,
                 guint8 port,
                 GList* payload);
static void ___lambda6__picolan_parser_on_datagram (picolanParser* _sender,
                                             guint8 src,
                                             guint8 dest,
                                             guint8 port,
                                             GList* payload,
                                             gpointer self);
static gboolean __lambda7_ (picolanInterface* self);
static gboolean ___lambda7__gsource_func (gpointer self);
gboolean picolan_interface_attach_socket (picolanInterface* self,
                                          picolanSocket* s);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static void ___lambda8_ (Block1Data* _data1_);
static void ____lambda8__picolan_socket_on_destroy (picolanSocket* _sender,
                                             gpointer self);
gboolean picolan_interface_open (picolanInterface* self,
                                 const gchar* port_name,
                                 gint baud,
                                 GError** error);
void picolan_interface_close (picolanInterface* self);
gpointer picolan_address_field_ref (gpointer instance);
void picolan_address_field_unref (gpointer instance);
GParamSpec* picolan_param_spec_address_field (const gchar* name,
                                              const gchar* nick,
                                              const gchar* blurb,
                                              GType object_type,
                                              GParamFlags flags);
void picolan_value_set_address_field (GValue* value,
                                      gpointer v_object);
void picolan_value_take_address_field (GValue* value,
                                       gpointer v_object);
gpointer picolan_value_get_address_field (const GValue* value);
GType picolan_address_field_get_type (void) G_GNUC_CONST;
picolanAddressField* picolan_address_field_new (void);
picolanAddressField* picolan_address_field_construct (GType object_type);
void picolan_address_field_set_address (picolanAddressField* self,
                                        guint8 addr);
guint8* picolan_address_field_get_bytes (picolanAddressField* self,
                                         gint* result_length1);
void picolan_interface_send_datagram (picolanInterface* self,
                                      guint8 dest,
                                      guint8 port_num,
                                      GList* data,
                                      GError** error);
static void picolan_interface_ping_data_free (gpointer _data);
static void picolan_interface_ping_async_ready_wrapper (GObject *source_object,
                                                 GAsyncResult *res,
                                                 void *user_data);
void picolan_interface_ping (picolanInterface* self,
                             guint8 addr,
                             guint timeout,
                             GAsyncReadyCallback _callback_,
                             gpointer _user_data_);
gint picolan_interface_ping_finish (picolanInterface* self,
                                    GAsyncResult* _res_,
                                    GError** error);
static gboolean picolan_interface_ping_co (PicolanInterfacePingData* _data_);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
static gboolean _picolan_interface_ping_co_gsource_func (gpointer self);
static void __lambda9_ (Block2Data* _data2_,
                 guint8 src,
                 guint8 dest,
                 guint8 p1,
                 guint8 p2);
static void ___lambda9__picolan_parser_on_ping_echo (picolanParser* _sender,
                                              guint8 src,
                                              guint8 dest,
                                              guint8 p1,
                                              guint8 p2,
                                              gpointer self);
static gboolean __lambda10_ (Block2Data* _data2_);
static gboolean ___lambda10__gsource_func (gpointer self);
void picolan_interface_subscribe (picolanInterface* self,
                                  guint8 port_num,
                                  GError** error);
void picolan_interface_unsubscribe (picolanInterface* self,
                                    guint8 port_num,
                                    GError** error);
static void picolan_interface_finalize (GObject * obj);
gint _vala_main (void);
static Block3Data* block3_data_ref (Block3Data* _data3_);
static void block3_data_unref (void * _userdata_);
GType picolan_datagram_get_type (void) G_GNUC_CONST;
static Block4Data* block4_data_ref (Block4Data* _data4_);
static void block4_data_unref (void * _userdata_);
static void ___lambda15_ (void);
static void ____lambda15__picolan_interface_on_close (picolanInterface* _sender,
                                               gpointer self);
static void ___lambda16_ (Block4Data* _data4_,
                   GObject* obj,
                   GAsyncResult* res);
static void ____lambda16__gasync_ready_callback (GObject* source_object,
                                          GAsyncResult* res,
                                          gpointer self);
picolanDatagram* picolan_datagram_new (guint8 _port);
picolanDatagram* picolan_datagram_construct (GType object_type,
                                             guint8 _port);
void picolan_socket_bind (picolanSocket* self,
                          picolanInterface* iface);
static void ___lambda17_ (GList* data);
static void ____lambda17__picolan_socket_on_data (picolanSocket* _sender,
                                           GList* data,
                                           gpointer self);
static gboolean ___lambda18_ (Block4Data* _data4_);
void picolan_datagram_send_string (picolanDatagram* self,
                                   guint8 dest,
                                   guint8 port,
                                   const gchar* str,
                                   GError** error);
static gboolean ____lambda18__gsource_func (gpointer self);

GType
picolan_packet_get_type (void)
{
	static volatile gsize picolan_packet_type_id__volatile = 0;
	if (g_once_init_enter (&picolan_packet_type_id__volatile)) {
		static const GEnumValue values[] = {{PICOLAN_PACKET_INVALID, "PICOLAN_PACKET_INVALID", "invalid"}, {PICOLAN_PACKET_GET_ADDR_LIST, "PICOLAN_PACKET_GET_ADDR_LIST", "get-addr-list"}, {PICOLAN_PACKET_ADDR, "PICOLAN_PACKET_ADDR", "addr"}, {PICOLAN_PACKET_PING, "PICOLAN_PACKET_PING", "ping"}, {PICOLAN_PACKET_PING_ECHO, "PICOLAN_PACKET_PING_ECHO", "ping-echo"}, {PICOLAN_PACKET_DATAGRAM, "PICOLAN_PACKET_DATAGRAM", "datagram"}, {PICOLAN_PACKET_SUBSCRIBE, "PICOLAN_PACKET_SUBSCRIBE", "subscribe"}, {PICOLAN_PACKET_NULL, "PICOLAN_PACKET_NULL", "null"}, {0, NULL, NULL}};
		GType picolan_packet_type_id;
		picolan_packet_type_id = g_enum_register_static ("picolanPACKET", values);
		g_once_init_leave (&picolan_packet_type_id__volatile, picolan_packet_type_id);
	}
	return picolan_packet_type_id__volatile;
}

GType
picolan_state_get_type (void)
{
	static volatile gsize picolan_state_type_id__volatile = 0;
	if (g_once_init_enter (&picolan_state_type_id__volatile)) {
		static const GEnumValue values[] = {{PICOLAN_STATE_START, "PICOLAN_STATE_START", "start"}, {PICOLAN_STATE_ID, "PICOLAN_STATE_ID", "id"}, {PICOLAN_STATE_SIZE, "PICOLAN_STATE_SIZE", "size"}, {PICOLAN_STATE_DATA, "PICOLAN_STATE_DATA", "data"}, {PICOLAN_STATE_CHECK1, "PICOLAN_STATE_CHECK1", "check1"}, {PICOLAN_STATE_CHECK2, "PICOLAN_STATE_CHECK2", "check2"}, {0, NULL, NULL}};
		GType picolan_state_type_id;
		picolan_state_type_id = g_enum_register_static ("picolanSTATE", values);
		g_once_init_leave (&picolan_state_type_id__volatile, picolan_state_type_id);
	}
	return picolan_state_type_id__volatile;
}

void
picolan_make_checksum (GList* bytes,
                       gint* sum1,
                       gint* sum2)
{
	gint _vala_sum1 = 0;
	gint _vala_sum2 = 0;
	gint index = 0;
	index = 0;
	_vala_sum2 = 0;
	_vala_sum1 = _vala_sum2;
	{
		gboolean _tmp0_ = FALSE;
		index = 0;
		_tmp0_ = TRUE;
		while (TRUE) {
			gconstpointer _tmp2_;
			if (!_tmp0_) {
				gint _tmp1_;
				_tmp1_ = index;
				index = _tmp1_ + 1;
			}
			_tmp0_ = FALSE;
			if (!(((guint) index) < g_list_length (bytes))) {
				break;
			}
			_tmp2_ = g_list_nth_data (bytes, (guint) index);
			_vala_sum1 = (_vala_sum1 + ((guint8) ((guintptr) _tmp2_))) % 255;
			_vala_sum2 = (_vala_sum2 + _vala_sum1) % 255;
		}
	}
	if (sum1) {
		*sum1 = _vala_sum1;
	}
	if (sum2) {
		*sum2 = _vala_sum2;
	}
}

static inline gpointer
picolan_port_map_get_instance_private (picolanPortMap* self)
{
	return G_STRUCT_MEMBER_P (self, picolanPortMap_private_offset);
}

static void
_g_object_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}

static inline void
_g_list_free__g_object_unref0_ (GList* self)
{
	g_list_free_full (self, (GDestroyNotify) _g_object_unref0_);
}

picolanPortMap*
picolan_port_map_construct (GType object_type)
{
	picolanPortMap * self = NULL;
	self = (picolanPortMap*) g_object_new (object_type, NULL);
	(self->priv->map == NULL) ? NULL : (self->priv->map = (_g_list_free__g_object_unref0_ (self->priv->map), NULL));
	self->priv->map = NULL;
	return self;
}

picolanPortMap*
picolan_port_map_new (void)
{
	return picolan_port_map_construct (PICOLAN_TYPE_PORT_MAP);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

void
picolan_port_map_add (picolanPortMap* self,
                      picolanSocket* socket)
{
	picolanSocket* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (socket != NULL);
	_tmp0_ = _g_object_ref0 (socket);
	self->priv->map = g_list_append (self->priv->map, _tmp0_);
}

void
picolan_port_map_remove (picolanPortMap* self,
                         picolanSocket* socket)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (socket != NULL);
	self->priv->map = g_list_remove (self->priv->map, socket);
}

gboolean
picolan_port_map_contains (picolanPortMap* self,
                           picolanSocket* socket)
{
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (socket != NULL, FALSE);
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				GList* _tmp2_;
				GList* _tmp3_;
				gconstpointer _tmp4_;
				if (!_tmp0_) {
					gint _tmp1_;
					_tmp1_ = i;
					i = _tmp1_ + 1;
				}
				_tmp0_ = FALSE;
				_tmp2_ = self->priv->map;
				if (!(((guint) i) < g_list_length (_tmp2_))) {
					break;
				}
				_tmp3_ = self->priv->map;
				_tmp4_ = g_list_nth_data (_tmp3_, (guint) i);
				if (picolan_socket_get_port ((picolanSocket*) _tmp4_) == picolan_socket_get_port (socket)) {
					result = TRUE;
					return result;
				}
			}
		}
	}
	result = FALSE;
	return result;
}

static void
picolan_port_map_class_init (picolanPortMapClass * klass,
                             gpointer klass_data)
{
	picolan_port_map_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &picolanPortMap_private_offset);
	G_OBJECT_CLASS (klass)->finalize = picolan_port_map_finalize;
}

static void
picolan_port_map_instance_init (picolanPortMap * self,
                                gpointer klass)
{
	self->priv = picolan_port_map_get_instance_private (self);
}

static void
picolan_port_map_finalize (GObject * obj)
{
	picolanPortMap * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PICOLAN_TYPE_PORT_MAP, picolanPortMap);
	(self->priv->map == NULL) ? NULL : (self->priv->map = (_g_list_free__g_object_unref0_ (self->priv->map), NULL));
	G_OBJECT_CLASS (picolan_port_map_parent_class)->finalize (obj);
}

GType
picolan_port_map_get_type (void)
{
	static volatile gsize picolan_port_map_type_id__volatile = 0;
	if (g_once_init_enter (&picolan_port_map_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (picolanPortMapClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) picolan_port_map_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (picolanPortMap), 0, (GInstanceInitFunc) picolan_port_map_instance_init, NULL };
		GType picolan_port_map_type_id;
		picolan_port_map_type_id = g_type_register_static (G_TYPE_OBJECT, "picolanPortMap", &g_define_type_info, 0);
		picolanPortMap_private_offset = g_type_add_instance_private (picolan_port_map_type_id, sizeof (picolanPortMapPrivate));
		g_once_init_leave (&picolan_port_map_type_id__volatile, picolan_port_map_type_id);
	}
	return picolan_port_map_type_id__volatile;
}

static inline gpointer
picolan_parser_get_instance_private (picolanParser* self)
{
	return G_STRUCT_MEMBER_P (self, picolanParser_private_offset);
}

picolanParser*
picolan_parser_construct (GType object_type)
{
	picolanParser * self = NULL;
	self = (picolanParser*) g_object_new (object_type, NULL);
	(self->priv->data == NULL) ? NULL : (self->priv->data = (g_list_free (self->priv->data), NULL));
	self->priv->data = NULL;
	return self;
}

picolanParser*
picolan_parser_new (void)
{
	return picolan_parser_construct (PICOLAN_TYPE_PARSER);
}

void
picolan_parser_read (picolanParser* self,
                     guint8 b)
{
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	if (((gint) b) == 0xAA) {
		_tmp0_ = self->priv->stuff_flag == FALSE;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		self->priv->stuff_flag = TRUE;
	} else {
		picolanSTATE _tmp2_;
		if (self->priv->stuff_flag == FALSE) {
			gboolean _tmp1_ = FALSE;
			if (((gint) b) == 0xAB) {
				_tmp1_ = TRUE;
			} else {
				_tmp1_ = ((gint) b) == 0xAC;
			}
			if (_tmp1_) {
				self->priv->state = PICOLAN_STATE_START;
			}
		}
		self->priv->stuff_flag = FALSE;
		_tmp2_ = self->priv->state;
		switch (_tmp2_) {
			case PICOLAN_STATE_START:
			{
				if (((gint) b) == 0xAB) {
					self->priv->state = PICOLAN_STATE_ID;
					(self->priv->data == NULL) ? NULL : (self->priv->data = (g_list_free (self->priv->data), NULL));
					self->priv->data = NULL;
				}
				break;
			}
			case PICOLAN_STATE_ID:
			{
				self->priv->id = b;
				self->priv->state = PICOLAN_STATE_SIZE;
				self->priv->data = g_list_append (self->priv->data, (gpointer) ((guintptr) b));
				break;
			}
			case PICOLAN_STATE_SIZE:
			{
				self->priv->size = b;
				self->priv->state = PICOLAN_STATE_DATA;
				self->priv->data = g_list_append (self->priv->data, (gpointer) ((guintptr) b));
				break;
			}
			case PICOLAN_STATE_DATA:
			{
				gboolean _tmp3_ = FALSE;
				GList* _tmp4_;
				self->priv->data = g_list_append (self->priv->data, (gpointer) ((guintptr) b));
				_tmp4_ = self->priv->data;
				if ((g_list_length (_tmp4_) - 2) >= ((guint) self->priv->size)) {
					_tmp3_ = TRUE;
				} else {
					GList* _tmp5_;
					_tmp5_ = self->priv->data;
					_tmp3_ = g_list_length (_tmp5_) >= ((guint) 255);
				}
				if (_tmp3_) {
					self->priv->state = PICOLAN_STATE_CHECK1;
				}
				break;
			}
			case PICOLAN_STATE_CHECK1:
			{
				self->priv->check1 = b;
				self->priv->state = PICOLAN_STATE_CHECK2;
				break;
			}
			case PICOLAN_STATE_CHECK2:
			{
				gint cs1 = 0;
				gint cs2 = 0;
				GList* _tmp6_;
				gint _tmp7_ = 0;
				gint _tmp8_ = 0;
				gboolean _tmp9_ = FALSE;
				self->priv->check2 = b;
				self->priv->state = PICOLAN_STATE_START;
				_tmp6_ = self->priv->data;
				picolan_make_checksum (_tmp6_, &_tmp7_, &_tmp8_);
				cs1 = _tmp7_;
				cs2 = _tmp8_;
				if (cs1 == ((gint) self->priv->check1)) {
					_tmp9_ = cs2 == ((gint) self->priv->check2);
				} else {
					_tmp9_ = FALSE;
				}
				if (_tmp9_) {
					GList* _tmp10_;
					GList* _tmp11_;
					GList* _tmp12_;
					GList* _tmp13_;
					_tmp10_ = self->priv->data;
					_tmp11_ = g_list_nth (_tmp10_, (guint) 0);
					self->priv->data = g_list_delete_link (self->priv->data, _tmp11_);
					_tmp12_ = self->priv->data;
					_tmp13_ = g_list_nth (_tmp12_, (guint) 0);
					self->priv->data = g_list_delete_link (self->priv->data, _tmp13_);
					picolan_parser_parse_packet (self);
				}
				break;
			}
			default:
			break;
		}
	}
}

static void
picolan_parser_parse_packet (picolanParser* self)
{
	g_return_if_fail (self != NULL);
	switch (self->priv->id) {
		case PICOLAN_PACKET_PING_ECHO:
		{
			GList* _tmp0_;
			gconstpointer _tmp1_;
			GList* _tmp2_;
			gconstpointer _tmp3_;
			GList* _tmp4_;
			gconstpointer _tmp5_;
			GList* _tmp6_;
			gconstpointer _tmp7_;
			_tmp0_ = self->priv->data;
			_tmp1_ = g_list_nth_data (_tmp0_, (guint) 1);
			_tmp2_ = self->priv->data;
			_tmp3_ = g_list_nth_data (_tmp2_, (guint) 2);
			_tmp4_ = self->priv->data;
			_tmp5_ = g_list_nth_data (_tmp4_, (guint) 3);
			_tmp6_ = self->priv->data;
			_tmp7_ = g_list_nth_data (_tmp6_, (guint) 4);
			g_signal_emit (self, picolan_parser_signals[PICOLAN_PARSER_ON_PING_ECHO_SIGNAL], 0, (guint8) ((guintptr) _tmp1_), (guint8) ((guintptr) _tmp3_), (guint8) ((guintptr) _tmp5_), (guint8) ((guintptr) _tmp7_));
			break;
		}
		case PICOLAN_PACKET_PING:
		{
			GList* _tmp8_;
			gconstpointer _tmp9_;
			GList* _tmp10_;
			gconstpointer _tmp11_;
			GList* _tmp12_;
			gconstpointer _tmp13_;
			GList* _tmp14_;
			gconstpointer _tmp15_;
			_tmp8_ = self->priv->data;
			_tmp9_ = g_list_nth_data (_tmp8_, (guint) 1);
			_tmp10_ = self->priv->data;
			_tmp11_ = g_list_nth_data (_tmp10_, (guint) 2);
			_tmp12_ = self->priv->data;
			_tmp13_ = g_list_nth_data (_tmp12_, (guint) 3);
			_tmp14_ = self->priv->data;
			_tmp15_ = g_list_nth_data (_tmp14_, (guint) 4);
			g_signal_emit (self, picolan_parser_signals[PICOLAN_PARSER_ON_PING_SIGNAL], 0, (guint8) ((guintptr) _tmp9_), (guint8) ((guintptr) _tmp11_), (guint8) ((guintptr) _tmp13_), (guint8) ((guintptr) _tmp15_));
			break;
		}
		case PICOLAN_PACKET_GET_ADDR_LIST:
		{
			g_signal_emit (self, picolan_parser_signals[PICOLAN_PARSER_ON_GET_ADDR_LIST_SIGNAL], 0);
			break;
		}
		case PICOLAN_PACKET_DATAGRAM:
		{
			GList* payload = NULL;
			GList* _tmp21_;
			gconstpointer _tmp22_;
			GList* _tmp23_;
			gconstpointer _tmp24_;
			GList* _tmp25_;
			gconstpointer _tmp26_;
			GList* _tmp27_;
			payload = NULL;
			{
				gint i = 0;
				i = 4;
				{
					gboolean _tmp16_ = FALSE;
					_tmp16_ = TRUE;
					while (TRUE) {
						GList* _tmp18_;
						GList* _tmp19_;
						gconstpointer _tmp20_;
						if (!_tmp16_) {
							gint _tmp17_;
							_tmp17_ = i;
							i = _tmp17_ + 1;
						}
						_tmp16_ = FALSE;
						_tmp18_ = self->priv->data;
						if (!(((guint) i) < g_list_length (_tmp18_))) {
							break;
						}
						_tmp19_ = self->priv->data;
						_tmp20_ = g_list_nth_data (_tmp19_, (guint) i);
						payload = g_list_append (payload, (gpointer) ((guintptr) ((guint8) ((guintptr) _tmp20_))));
					}
				}
			}
			_tmp21_ = self->priv->data;
			_tmp22_ = g_list_nth_data (_tmp21_, (guint) 1);
			_tmp23_ = self->priv->data;
			_tmp24_ = g_list_nth_data (_tmp23_, (guint) 2);
			_tmp25_ = self->priv->data;
			_tmp26_ = g_list_nth_data (_tmp25_, (guint) 3);
			_tmp27_ = payload;
			g_signal_emit (self, picolan_parser_signals[PICOLAN_PARSER_ON_DATAGRAM_SIGNAL], 0, (guint8) ((guintptr) _tmp22_), (guint8) ((guintptr) _tmp24_), (guint8) ((guintptr) _tmp26_), _tmp27_);
			(payload == NULL) ? NULL : (payload = (g_list_free (payload), NULL));
			break;
		}
		default:
		break;
	}
}

static void
g_cclosure_user_marshal_VOID__UCHAR_UCHAR_UCHAR_UCHAR (GClosure * closure,
                                                       GValue * return_value,
                                                       guint n_param_values,
                                                       const GValue * param_values,
                                                       gpointer invocation_hint,
                                                       gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__UCHAR_UCHAR_UCHAR_UCHAR) (gpointer data1, guint8 arg_1, guint8 arg_2, guint8 arg_3, guint8 arg_4, gpointer data2);
	register GMarshalFunc_VOID__UCHAR_UCHAR_UCHAR_UCHAR callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 5);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__UCHAR_UCHAR_UCHAR_UCHAR) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_uchar (param_values + 1), g_value_get_uchar (param_values + 2), g_value_get_uchar (param_values + 3), g_value_get_uchar (param_values + 4), data2);
}

static void
g_cclosure_user_marshal_VOID__UCHAR_UCHAR_UCHAR_POINTER (GClosure * closure,
                                                         GValue * return_value,
                                                         guint n_param_values,
                                                         const GValue * param_values,
                                                         gpointer invocation_hint,
                                                         gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__UCHAR_UCHAR_UCHAR_POINTER) (gpointer data1, guint8 arg_1, guint8 arg_2, guint8 arg_3, gpointer arg_4, gpointer data2);
	register GMarshalFunc_VOID__UCHAR_UCHAR_UCHAR_POINTER callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 5);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__UCHAR_UCHAR_UCHAR_POINTER) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_uchar (param_values + 1), g_value_get_uchar (param_values + 2), g_value_get_uchar (param_values + 3), g_value_get_pointer (param_values + 4), data2);
}

static void
picolan_parser_class_init (picolanParserClass * klass,
                           gpointer klass_data)
{
	picolan_parser_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &picolanParser_private_offset);
	G_OBJECT_CLASS (klass)->finalize = picolan_parser_finalize;
	picolan_parser_signals[PICOLAN_PARSER_ON_GET_ADDR_LIST_SIGNAL] = g_signal_new ("on-get-addr-list", PICOLAN_TYPE_PARSER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	picolan_parser_signals[PICOLAN_PARSER_ON_ADDR_SIGNAL] = g_signal_new ("on-addr", PICOLAN_TYPE_PARSER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__UCHAR, G_TYPE_NONE, 1, G_TYPE_UCHAR);
	picolan_parser_signals[PICOLAN_PARSER_ON_PING_SIGNAL] = g_signal_new ("on-ping", PICOLAN_TYPE_PARSER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__UCHAR_UCHAR_UCHAR_UCHAR, G_TYPE_NONE, 4, G_TYPE_UCHAR, G_TYPE_UCHAR, G_TYPE_UCHAR, G_TYPE_UCHAR);
	picolan_parser_signals[PICOLAN_PARSER_ON_PING_ECHO_SIGNAL] = g_signal_new ("on-ping-echo", PICOLAN_TYPE_PARSER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__UCHAR_UCHAR_UCHAR_UCHAR, G_TYPE_NONE, 4, G_TYPE_UCHAR, G_TYPE_UCHAR, G_TYPE_UCHAR, G_TYPE_UCHAR);
	picolan_parser_signals[PICOLAN_PARSER_ON_DATAGRAM_SIGNAL] = g_signal_new ("on-datagram", PICOLAN_TYPE_PARSER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__UCHAR_UCHAR_UCHAR_POINTER, G_TYPE_NONE, 4, G_TYPE_UCHAR, G_TYPE_UCHAR, G_TYPE_UCHAR, G_TYPE_POINTER);
}

static void
picolan_parser_instance_init (picolanParser * self,
                              gpointer klass)
{
	self->priv = picolan_parser_get_instance_private (self);
	self->priv->stuff_flag = FALSE;
}

static void
picolan_parser_finalize (GObject * obj)
{
	picolanParser * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PICOLAN_TYPE_PARSER, picolanParser);
	(self->priv->data == NULL) ? NULL : (self->priv->data = (g_list_free (self->priv->data), NULL));
	G_OBJECT_CLASS (picolan_parser_parent_class)->finalize (obj);
}

GType
picolan_parser_get_type (void)
{
	static volatile gsize picolan_parser_type_id__volatile = 0;
	if (g_once_init_enter (&picolan_parser_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (picolanParserClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) picolan_parser_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (picolanParser), 0, (GInstanceInitFunc) picolan_parser_instance_init, NULL };
		GType picolan_parser_type_id;
		picolan_parser_type_id = g_type_register_static (G_TYPE_OBJECT, "picolanParser", &g_define_type_info, 0);
		picolanParser_private_offset = g_type_add_instance_private (picolan_parser_type_id, sizeof (picolanParserPrivate));
		g_once_init_leave (&picolan_parser_type_id__volatile, picolan_parser_type_id);
	}
	return picolan_parser_type_id__volatile;
}

GQuark
picolan_picolan_error_quark (void)
{
	return g_quark_from_static_string ("picolan-picolan-error-quark");
}

static inline gpointer
picolan_interface_get_instance_private (picolanInterface* self)
{
	return G_STRUCT_MEMBER_P (self, picolanInterface_private_offset);
}

static void
__lambda4_ (picolanInterface* self,
            guint8 src,
            guint8 dest,
            guint8 p1,
            guint8 p2)
{
	GList* msg = NULL;
	gint cs1 = 0;
	gint cs2 = 0;
	GList* _tmp0_;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	GList* _tmp3_;
	GList* _tmp4_;
	GError* _inner_error0_ = NULL;
	msg = NULL;
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) PICOLAN_PACKET_PING_ECHO)));
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) 5)));
	msg = g_list_append (msg, (gpointer) ((guintptr) self->ttl));
	msg = g_list_append (msg, (gpointer) ((guintptr) self->priv->address));
	msg = g_list_append (msg, (gpointer) ((guintptr) src));
	msg = g_list_append (msg, (gpointer) ((guintptr) p1));
	msg = g_list_append (msg, (gpointer) ((guintptr) p2));
	_tmp0_ = msg;
	picolan_make_checksum (_tmp0_, &_tmp1_, &_tmp2_);
	cs1 = _tmp1_;
	cs2 = _tmp2_;
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) cs1)));
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) cs2)));
	_tmp3_ = msg;
	_tmp4_ = picolan_interface_stuff_bytes (self, _tmp3_);
	(msg == NULL) ? NULL : (msg = (g_list_free (msg), NULL));
	msg = _tmp4_;
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) 0xAC)));
	msg = g_list_insert (msg, (gpointer) ((guintptr) ((guint8) 0xAB)), 0);
	{
		GList* _tmp5_;
		_tmp5_ = msg;
		picolan_interface_write_list (self, _tmp5_);
	}
	goto __finally2;
	__catch2_g_error:
	{
		GError* _error_ = NULL;
		FILE* _tmp6_;
		FILE* _tmp7_;
		GError* _tmp8_;
		const gchar* _tmp9_;
		_error_ = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp6_ = stdout;
		fprintf (_tmp6_, "Error while responding to a ping.\n");
		_tmp7_ = stdout;
		_tmp8_ = _error_;
		_tmp9_ = _tmp8_->message;
		fprintf (_tmp7_, "%s\n", _tmp9_);
		_g_error_free0 (_error_);
	}
	__finally2:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		(msg == NULL) ? NULL : (msg = (g_list_free (msg), NULL));
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	(msg == NULL) ? NULL : (msg = (g_list_free (msg), NULL));
}

static void
___lambda4__picolan_parser_on_ping (picolanParser* _sender,
                                    guint8 src,
                                    guint8 dest,
                                    guint8 p1,
                                    guint8 p2,
                                    gpointer self)
{
	__lambda4_ ((picolanInterface*) self, src, dest, p1, p2);
}

static void
__lambda5_ (picolanInterface* self)
{
	GError* _inner_error0_ = NULL;
	{
		picolan_interface_set_address (self, self->priv->address, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch3_g_error;
		}
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError* _error_ = NULL;
		FILE* _tmp0_;
		FILE* _tmp1_;
		GError* _tmp2_;
		const gchar* _tmp3_;
		_error_ = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp0_ = stdout;
		fprintf (_tmp0_, "Error responding to request for this address.\n");
		_tmp1_ = stdout;
		_tmp2_ = _error_;
		_tmp3_ = _tmp2_->message;
		fprintf (_tmp1_, "%s\n", _tmp3_);
		_g_error_free0 (_error_);
	}
	__finally3:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}

static void
___lambda5__picolan_parser_on_get_addr_list (picolanParser* _sender,
                                             gpointer self)
{
	__lambda5_ ((picolanInterface*) self);
}

static void
__lambda6_ (picolanInterface* self,
            guint8 src,
            guint8 dest,
            guint8 port,
            GList* payload)
{
	g_signal_emit (self, picolan_interface_signals[PICOLAN_INTERFACE_ON_DATAGRAM_SIGNAL], 0, src, dest, port, payload);
}

static void
___lambda6__picolan_parser_on_datagram (picolanParser* _sender,
                                        guint8 src,
                                        guint8 dest,
                                        guint8 port,
                                        GList* payload,
                                        gpointer self)
{
	__lambda6_ ((picolanInterface*) self, src, dest, port, payload);
}

static gboolean
__lambda7_ (picolanInterface* self)
{
	gboolean result = FALSE;
	gserialPort* _tmp0_;
	GError* _inner_error0_ = NULL;
	_tmp0_ = self->priv->port;
	if (gserial_port_is_open (_tmp0_)) {
		{
			guint _tmp1_ = 0U;
			gserialPort* _tmp2_;
			_tmp2_ = self->priv->port;
			_tmp1_ = gserial_port_available (_tmp2_, &_inner_error0_);
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				goto __catch4_g_error;
			}
			if (_tmp1_ > ((guint) 0)) {
				guint len = 0U;
				gserialPort* _tmp3_;
				GArray* bytes = NULL;
				GArray* _tmp4_;
				gserialPort* _tmp5_;
				GArray* _tmp6_ = NULL;
				_tmp3_ = self->priv->port;
				len = gserial_port_available (_tmp3_, &_inner_error0_);
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
					goto __catch4_g_error;
				}
				_tmp4_ = g_array_new (TRUE, TRUE, sizeof (gchar));
				bytes = _tmp4_;
				_tmp5_ = self->priv->port;
				gserial_port_read_bytes (_tmp5_, len, &_tmp6_, &_inner_error0_);
				_g_array_unref0 (bytes);
				bytes = _tmp6_;
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
					_g_array_unref0 (bytes);
					goto __catch4_g_error;
				}
				{
					guint i = 0U;
					i = (guint) 0;
					{
						gboolean _tmp7_ = FALSE;
						_tmp7_ = TRUE;
						while (TRUE) {
							GArray* _tmp9_;
							picolanParser* _tmp10_;
							GArray* _tmp11_;
							if (!_tmp7_) {
								guint _tmp8_;
								_tmp8_ = i;
								i = _tmp8_ + 1;
							}
							_tmp7_ = FALSE;
							_tmp9_ = bytes;
							if (!(i < _tmp9_->len)) {
								break;
							}
							_tmp10_ = self->priv->parser;
							_tmp11_ = bytes;
							picolan_parser_read (_tmp10_, (guint8) g_array_index (_tmp11_, gchar, i));
						}
					}
				}
				_g_array_unref0 (bytes);
			}
		}
		goto __finally4;
		__catch4_g_error:
		{
			GError* e = NULL;
			FILE* _tmp12_;
			GError* _tmp13_;
			const gchar* _tmp14_;
			gserialPort* _tmp15_;
			e = _inner_error0_;
			_inner_error0_ = NULL;
			_tmp12_ = stdout;
			_tmp13_ = e;
			_tmp14_ = _tmp13_->message;
			fprintf (_tmp12_, "Error in loop: %s\n", _tmp14_);
			_tmp15_ = self->priv->port;
			gserial_port_close (_tmp15_);
			g_signal_emit (self, picolan_interface_signals[PICOLAN_INTERFACE_ON_CLOSE_SIGNAL], 0);
			_g_error_free0 (e);
		}
		__finally4:
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			gboolean _tmp16_ = FALSE;
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return _tmp16_;
		}
	}
	result = TRUE;
	return result;
}

static gboolean
___lambda7__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda7_ ((picolanInterface*) self);
	return result;
}

picolanInterface*
picolan_interface_construct (GType object_type)
{
	picolanInterface * self = NULL;
	picolanParser* _tmp0_;
	picolanPortMap* _tmp1_;
	picolanParser* _tmp2_;
	picolanParser* _tmp3_;
	picolanParser* _tmp4_;
	self = (picolanInterface*) g_object_new (object_type, NULL);
	_tmp0_ = picolan_parser_new ();
	_g_object_unref0 (self->priv->parser);
	self->priv->parser = _tmp0_;
	_tmp1_ = picolan_port_map_new ();
	_g_object_unref0 (self->priv->port_map);
	self->priv->port_map = _tmp1_;
	_tmp2_ = self->priv->parser;
	g_signal_connect_object (_tmp2_, "on-ping", (GCallback) ___lambda4__picolan_parser_on_ping, self, 0);
	_tmp3_ = self->priv->parser;
	g_signal_connect_object (_tmp3_, "on-get-addr-list", (GCallback) ___lambda5__picolan_parser_on_get_addr_list, self, 0);
	_tmp4_ = self->priv->parser;
	g_signal_connect_object (_tmp4_, "on-datagram", (GCallback) ___lambda6__picolan_parser_on_datagram, self, 0);
	g_timeout_add_full (1, (guint) 10, ___lambda7__gsource_func, g_object_ref (self), g_object_unref);
	return self;
}

picolanInterface*
picolan_interface_new (void)
{
	return picolan_interface_construct (PICOLAN_TYPE_INTERFACE);
}

static Block1Data*
block1_data_ref (Block1Data* _data1_)
{
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}

static void
block1_data_unref (void * _userdata_)
{
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		picolanInterface* self;
		self = _data1_->self;
		_g_object_unref0 (_data1_->s);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}

static void
___lambda8_ (Block1Data* _data1_)
{
	picolanInterface* self;
	picolanPortMap* _tmp0_;
	self = _data1_->self;
	_tmp0_ = self->priv->port_map;
	picolan_port_map_remove (_tmp0_, _data1_->s);
}

static void
____lambda8__picolan_socket_on_destroy (picolanSocket* _sender,
                                        gpointer self)
{
	___lambda8_ (self);
}

gboolean
picolan_interface_attach_socket (picolanInterface* self,
                                 picolanSocket* s)
{
	gboolean result = FALSE;
	Block1Data* _data1_;
	picolanSocket* _tmp0_;
	picolanPortMap* _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (s != NULL, FALSE);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	_tmp0_ = _g_object_ref0 (s);
	_g_object_unref0 (_data1_->s);
	_data1_->s = _tmp0_;
	_tmp1_ = self->priv->port_map;
	if (picolan_port_map_contains (_tmp1_, _data1_->s) == FALSE) {
		picolanPortMap* _tmp2_;
		_tmp2_ = self->priv->port_map;
		picolan_port_map_add (_tmp2_, _data1_->s);
		g_signal_connect_data (_data1_->s, "on-destroy", (GCallback) ____lambda8__picolan_socket_on_destroy, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
		result = TRUE;
		block1_data_unref (_data1_);
		_data1_ = NULL;
		return result;
	} else {
		result = FALSE;
		block1_data_unref (_data1_);
		_data1_ = NULL;
		return result;
	}
	block1_data_unref (_data1_);
	_data1_ = NULL;
}

gboolean
picolan_interface_open (picolanInterface* self,
                        const gchar* port_name,
                        gint baud,
                        GError** error)
{
	gboolean result = FALSE;
	gserialPort* _tmp0_;
	gserialPort* _tmp1_;
	gserialPort* _tmp2_;
	gserialPort* _tmp4_;
	GError* _inner_error0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (port_name != NULL, FALSE);
	_tmp0_ = gserial_port_new ();
	_g_object_unref0 (self->priv->port);
	self->priv->port = _tmp0_;
	_tmp1_ = self->priv->port;
	gserial_port_set_baud (_tmp1_, baud);
	_tmp2_ = self->priv->port;
	gserial_port_open (_tmp2_, port_name, &_inner_error0_);
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		gboolean _tmp3_ = FALSE;
		g_propagate_error (error, _inner_error0_);
		return _tmp3_;
	}
	_tmp4_ = self->priv->port;
	result = gserial_port_is_open (_tmp4_);
	return result;
}

void
picolan_interface_close (picolanInterface* self)
{
	gserialPort* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->port;
	gserial_port_close (_tmp0_);
	g_signal_emit (self, picolan_interface_signals[PICOLAN_INTERFACE_ON_CLOSE_SIGNAL], 0);
}

void
picolan_interface_set_address (picolanInterface* self,
                               guint8 addr,
                               GError** error)
{
	picolanAddressField* af = NULL;
	picolanAddressField* _tmp0_;
	picolanAddressField* _tmp1_;
	GList* msg = NULL;
	gint cs1 = 0;
	gint cs2 = 0;
	GList* _tmp9_;
	gint _tmp10_ = 0;
	gint _tmp11_ = 0;
	GList* _tmp12_;
	GList* _tmp13_;
	GList* _tmp14_;
	g_return_if_fail (self != NULL);
	self->priv->address = addr;
	_tmp0_ = picolan_address_field_new ();
	af = _tmp0_;
	_tmp1_ = af;
	picolan_address_field_set_address (_tmp1_, addr);
	msg = NULL;
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) PICOLAN_PACKET_ADDR)));
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) 32)));
	msg = g_list_append (msg, (gpointer) ((guintptr) self->ttl));
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				picolanAddressField* _tmp4_;
				gint _tmp5_ = 0;
				guint8* _tmp6_;
				guint8* _tmp7_;
				gint _tmp7__length1;
				guint8 _tmp8_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp2_ = FALSE;
				if (!(i < 32)) {
					break;
				}
				_tmp4_ = af;
				_tmp6_ = picolan_address_field_get_bytes (_tmp4_, &_tmp5_);
				_tmp7_ = _tmp6_;
				_tmp7__length1 = _tmp5_;
				_tmp8_ = _tmp7_[i];
				msg = g_list_append (msg, (gpointer) ((guintptr) _tmp8_));
				_tmp7_ = (g_free (_tmp7_), NULL);
			}
		}
	}
	_tmp9_ = msg;
	picolan_make_checksum (_tmp9_, &_tmp10_, &_tmp11_);
	cs1 = _tmp10_;
	cs2 = _tmp11_;
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) cs1)));
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) cs2)));
	_tmp12_ = msg;
	_tmp13_ = picolan_interface_stuff_bytes (self, _tmp12_);
	(msg == NULL) ? NULL : (msg = (g_list_free (msg), NULL));
	msg = _tmp13_;
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) 0xAC)));
	msg = g_list_insert (msg, (gpointer) ((guintptr) ((guint8) 0xAB)), 0);
	_tmp14_ = msg;
	picolan_interface_write_list (self, _tmp14_);
	(msg == NULL) ? NULL : (msg = (g_list_free (msg), NULL));
	_picolan_address_field_unref0 (af);
}

void
picolan_interface_send_datagram (picolanInterface* self,
                                 guint8 dest,
                                 guint8 port_num,
                                 GList* data,
                                 GError** error)
{
	GList* msg = NULL;
	gint cs1 = 0;
	gint cs2 = 0;
	GList* _tmp4_;
	gint _tmp5_ = 0;
	gint _tmp6_ = 0;
	GList* _tmp7_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	if (g_list_length (data) >= ((guint) 250)) {
		GError* _tmp0_;
		_tmp0_ = g_error_new_literal (PICOLAN_PICOLAN_ERROR, PICOLAN_PICOLAN_ERROR_PAYLOAD_TOO_BIG, "Payload size is greater than the maximum of 250 bytes");
		_inner_error0_ = _tmp0_;
		g_propagate_error (error, _inner_error0_);
		return;
	}
	msg = NULL;
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) PICOLAN_PACKET_DATAGRAM)));
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) (g_list_length (data) + 5))));
	msg = g_list_append (msg, (gpointer) ((guintptr) self->ttl));
	msg = g_list_append (msg, (gpointer) ((guintptr) self->priv->address));
	msg = g_list_append (msg, (gpointer) ((guintptr) dest));
	msg = g_list_append (msg, (gpointer) ((guintptr) port_num));
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) g_list_length (data))));
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp1_ = FALSE;
			_tmp1_ = TRUE;
			while (TRUE) {
				gconstpointer _tmp3_;
				if (!_tmp1_) {
					gint _tmp2_;
					_tmp2_ = i;
					i = _tmp2_ + 1;
				}
				_tmp1_ = FALSE;
				if (!(((guint) i) < g_list_length (data))) {
					break;
				}
				_tmp3_ = g_list_nth_data (data, (guint) i);
				msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) ((guintptr) _tmp3_))));
			}
		}
	}
	_tmp4_ = msg;
	picolan_make_checksum (_tmp4_, &_tmp5_, &_tmp6_);
	cs1 = _tmp5_;
	cs2 = _tmp6_;
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) cs1)));
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) cs2)));
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) 0xAC)));
	msg = g_list_insert (msg, (gpointer) ((guintptr) ((guint8) 0xAB)), 0);
	_tmp7_ = msg;
	picolan_interface_write_list (self, _tmp7_);
	(msg == NULL) ? NULL : (msg = (g_list_free (msg), NULL));
}

static void
picolan_interface_ping_data_free (gpointer _data)
{
	PicolanInterfacePingData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (PicolanInterfacePingData, _data_);
}

static void
picolan_interface_ping_async_ready_wrapper (GObject *source_object,
                                            GAsyncResult *res,
                                            void *user_data)
{
	PicolanInterfacePingData* _task_data_;
	_task_data_ = g_task_get_task_data (G_TASK (res));
	if (_task_data_->_callback_ != NULL) {
		_task_data_->_callback_ (source_object, res, user_data);
	}
	_task_data_->_task_complete_ = TRUE;
}

void
picolan_interface_ping (picolanInterface* self,
                        guint8 addr,
                        guint timeout,
                        GAsyncReadyCallback _callback_,
                        gpointer _user_data_)
{
	PicolanInterfacePingData* _data_;
	picolanInterface* _tmp0_;
	_data_ = g_slice_new0 (PicolanInterfacePingData);
	_data_->_callback_ = _callback_;
	_data_->_async_result = g_task_new (G_OBJECT (self), NULL, picolan_interface_ping_async_ready_wrapper, _user_data_);
	if (_callback_ == NULL) {
		_data_->_task_complete_ = TRUE;
	}
	g_task_set_task_data (_data_->_async_result, _data_, picolan_interface_ping_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_data_->addr = addr;
	_data_->timeout = timeout;
	picolan_interface_ping_co (_data_);
}

gint
picolan_interface_ping_finish (picolanInterface* self,
                               GAsyncResult* _res_,
                               GError** error)
{
	gint result;
	PicolanInterfacePingData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), error);
	if (NULL == _data_) {
		gint _tmp0_ = 0;
		return _tmp0_;
	}
	result = _data_->result;
	return result;
}

static Block2Data*
block2_data_ref (Block2Data* _data2_)
{
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}

static void
block2_data_unref (void * _userdata_)
{
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		picolanInterface* self;
		self = _data2_->self;
		_g_timer_destroy0 (_data2_->timer);
		(_data2_->callback_target_destroy_notify == NULL) ? NULL : (_data2_->callback_target_destroy_notify (_data2_->callback_target), NULL);
		_data2_->callback = NULL;
		_data2_->callback_target = NULL;
		_data2_->callback_target_destroy_notify = NULL;
		_g_object_unref0 (self);
		g_slice_free (Block2Data, _data2_);
	}
}

static gboolean
_picolan_interface_ping_co_gsource_func (gpointer self)
{
	gboolean result;
	result = picolan_interface_ping_co (self);
	return result;
}

static void
__lambda9_ (Block2Data* _data2_,
            guint8 src,
            guint8 dest,
            guint8 p1,
            guint8 p2)
{
	picolanInterface* self;
	gboolean _tmp0_ = FALSE;
	self = _data2_->self;
	if (p1 == _data2_->payload1) {
		_tmp0_ = p2 == _data2_->payload2;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gulong micros = 0UL;
		gulong _tmp1_ = 0UL;
		GSourceFunc _tmp2_;
		gpointer _tmp2__target;
		GDestroyNotify _tmp2__target_destroy_notify;
		picolanParser* _tmp3_;
		micros = (gulong) 0;
		g_timer_elapsed (_data2_->timer, &_tmp1_);
		micros = _tmp1_;
		_data2_->ping_time = (gint) (micros / 1000);
		_tmp2_ = _data2_->callback;
		_tmp2__target = _data2_->callback_target;
		_tmp2__target_destroy_notify = _data2_->callback_target_destroy_notify;
		_data2_->callback = NULL;
		_data2_->callback_target = NULL;
		_data2_->callback_target_destroy_notify = NULL;
		g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, _tmp2_, _tmp2__target, _tmp2__target_destroy_notify);
		_tmp3_ = self->priv->parser;
		g_signal_handler_disconnect ((GObject*) _tmp3_, _data2_->handle);
		g_source_remove (_data2_->timeout_handle);
	}
}

static void
___lambda9__picolan_parser_on_ping_echo (picolanParser* _sender,
                                         guint8 src,
                                         guint8 dest,
                                         guint8 p1,
                                         guint8 p2,
                                         gpointer self)
{
	__lambda9_ (self, src, dest, p1, p2);
}

static gboolean
__lambda10_ (Block2Data* _data2_)
{
	picolanInterface* self;
	gboolean result = FALSE;
	GSourceFunc _tmp0_;
	gpointer _tmp0__target;
	GDestroyNotify _tmp0__target_destroy_notify;
	picolanParser* _tmp1_;
	self = _data2_->self;
	_tmp0_ = _data2_->callback;
	_tmp0__target = _data2_->callback_target;
	_tmp0__target_destroy_notify = _data2_->callback_target_destroy_notify;
	_data2_->callback = NULL;
	_data2_->callback_target = NULL;
	_data2_->callback_target_destroy_notify = NULL;
	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, _tmp0_, _tmp0__target, _tmp0__target_destroy_notify);
	_tmp1_ = self->priv->parser;
	g_signal_handler_disconnect ((GObject*) _tmp1_, _data2_->handle);
	result = FALSE;
	return result;
}

static gboolean
___lambda10__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda10_ (self);
	return result;
}

static gboolean
picolan_interface_ping_co (PicolanInterfacePingData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_data2_ = g_slice_new0 (Block2Data);
	_data_->_data2_->_ref_count_ = 1;
	_data_->_data2_->self = g_object_ref (_data_->self);
	_data_->_data2_->_async_data_ = _data_;
	_data_->_data2_->callback = _picolan_interface_ping_co_gsource_func;
	_data_->_data2_->callback_target = _data_;
	_data_->_data2_->callback_target_destroy_notify = NULL;
	_data_->_data2_->payload1 = (guint8) g_random_int_range ((gint32) 0, (gint32) 255);
	_data_->_data2_->payload2 = (guint8) g_random_int_range ((gint32) 0, (gint32) 255);
	_data_->_data2_->ping_time = -1;
	_data_->_tmp0_ = g_timer_new ();
	_data_->_data2_->timer = _data_->_tmp0_;
	_data_->_data2_->timeout_handle = (guint) 0;
	_data_->_data2_->handle = (gulong) 0;
	_data_->_tmp1_ = _data_->self->priv->parser;
	_data_->_tmp2_ = g_signal_connect_data (_data_->_tmp1_, "on-ping-echo", (GCallback) ___lambda9__picolan_parser_on_ping_echo, block2_data_ref (_data_->_data2_), (GClosureNotify) block2_data_unref, 0);
	_data_->_data2_->handle = _data_->_tmp2_;
	_data_->_data2_->timeout_handle = g_timeout_add_full (G_PRIORITY_DEFAULT, _data_->timeout, ___lambda10__gsource_func, block2_data_ref (_data_->_data2_), block2_data_unref);
	_data_->msg = NULL;
	_data_->msg = g_list_append (_data_->msg, (gpointer) ((guintptr) ((guint8) PICOLAN_PACKET_PING)));
	_data_->msg = g_list_append (_data_->msg, (gpointer) ((guintptr) ((guint8) 5)));
	_data_->msg = g_list_append (_data_->msg, (gpointer) ((guintptr) _data_->self->ttl));
	_data_->msg = g_list_append (_data_->msg, (gpointer) ((guintptr) _data_->self->priv->address));
	_data_->msg = g_list_append (_data_->msg, (gpointer) ((guintptr) _data_->addr));
	_data_->msg = g_list_append (_data_->msg, (gpointer) ((guintptr) _data_->_data2_->payload1));
	_data_->msg = g_list_append (_data_->msg, (gpointer) ((guintptr) _data_->_data2_->payload2));
	_data_->_tmp3_ = _data_->msg;
	_data_->_tmp4_ = 0;
	_data_->_tmp5_ = 0;
	picolan_make_checksum (_data_->_tmp3_, &_data_->_tmp4_, &_data_->_tmp5_);
	_data_->cs1 = _data_->_tmp4_;
	_data_->cs2 = _data_->_tmp5_;
	_data_->msg = g_list_append (_data_->msg, (gpointer) ((guintptr) ((guint8) _data_->cs1)));
	_data_->msg = g_list_append (_data_->msg, (gpointer) ((guintptr) ((guint8) _data_->cs2)));
	_data_->_tmp6_ = _data_->msg;
	_data_->_tmp7_ = picolan_interface_stuff_bytes (_data_->self, _data_->_tmp6_);
	(_data_->msg == NULL) ? NULL : (_data_->msg = (g_list_free (_data_->msg), NULL));
	_data_->msg = _data_->_tmp7_;
	_data_->msg = g_list_append (_data_->msg, (gpointer) ((guintptr) ((guint8) 0xAC)));
	_data_->msg = g_list_insert (_data_->msg, (gpointer) ((guintptr) ((guint8) 0xAB)), 0);
	_data_->_tmp8_ = _data_->msg;
	picolan_interface_write_list (_data_->self, _data_->_tmp8_);
	_data_->_state_ = 1;
	return FALSE;
	_state_1:
	;
	_data_->result = _data_->_data2_->ping_time;
	(_data_->msg == NULL) ? NULL : (_data_->msg = (g_list_free (_data_->msg), NULL));
	block2_data_unref (_data_->_data2_);
	_data_->_data2_ = NULL;
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!_data_->_task_complete_) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

void
picolan_interface_subscribe (picolanInterface* self,
                             guint8 port_num,
                             GError** error)
{
	GList* msg = NULL;
	gint cs1 = 0;
	gint cs2 = 0;
	GList* _tmp0_;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	GList* _tmp3_;
	GList* _tmp4_;
	GList* _tmp5_;
	g_return_if_fail (self != NULL);
	msg = NULL;
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) PICOLAN_PACKET_SUBSCRIBE)));
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) 4)));
	msg = g_list_append (msg, (gpointer) ((guintptr) self->ttl));
	msg = g_list_append (msg, (gpointer) ((guintptr) port_num));
	msg = g_list_append (msg, (gpointer) ((guintptr) self->priv->address));
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) 1)));
	_tmp0_ = msg;
	picolan_make_checksum (_tmp0_, &_tmp1_, &_tmp2_);
	cs1 = _tmp1_;
	cs2 = _tmp2_;
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) cs1)));
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) cs2)));
	_tmp3_ = msg;
	_tmp4_ = picolan_interface_stuff_bytes (self, _tmp3_);
	(msg == NULL) ? NULL : (msg = (g_list_free (msg), NULL));
	msg = _tmp4_;
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) 0xAC)));
	msg = g_list_insert (msg, (gpointer) ((guintptr) ((guint8) 0xAB)), 0);
	_tmp5_ = msg;
	picolan_interface_write_list (self, _tmp5_);
	(msg == NULL) ? NULL : (msg = (g_list_free (msg), NULL));
}

void
picolan_interface_unsubscribe (picolanInterface* self,
                               guint8 port_num,
                               GError** error)
{
	GList* msg = NULL;
	gint cs1 = 0;
	gint cs2 = 0;
	GList* _tmp0_;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	GList* _tmp3_;
	GList* _tmp4_;
	GList* _tmp5_;
	g_return_if_fail (self != NULL);
	msg = NULL;
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) PICOLAN_PACKET_SUBSCRIBE)));
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) 4)));
	msg = g_list_append (msg, (gpointer) ((guintptr) self->ttl));
	msg = g_list_append (msg, (gpointer) ((guintptr) port_num));
	msg = g_list_append (msg, (gpointer) ((guintptr) self->priv->address));
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) 0)));
	_tmp0_ = msg;
	picolan_make_checksum (_tmp0_, &_tmp1_, &_tmp2_);
	cs1 = _tmp1_;
	cs2 = _tmp2_;
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) cs1)));
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) cs2)));
	_tmp3_ = msg;
	_tmp4_ = picolan_interface_stuff_bytes (self, _tmp3_);
	(msg == NULL) ? NULL : (msg = (g_list_free (msg), NULL));
	msg = _tmp4_;
	msg = g_list_append (msg, (gpointer) ((guintptr) ((guint8) 0xAC)));
	msg = g_list_insert (msg, (gpointer) ((guintptr) ((guint8) 0xAB)), 0);
	_tmp5_ = msg;
	picolan_interface_write_list (self, _tmp5_);
	(msg == NULL) ? NULL : (msg = (g_list_free (msg), NULL));
}

static GList*
picolan_interface_stuff_bytes (picolanInterface* self,
                               GList* bytes)
{
	GList* result = NULL;
	GList* ret = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	ret = NULL;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				gconstpointer _tmp2_;
				if (!_tmp0_) {
					gint _tmp1_;
					_tmp1_ = i;
					i = _tmp1_ + 1;
				}
				_tmp0_ = FALSE;
				if (!(((guint) i) < g_list_length (bytes))) {
					break;
				}
				_tmp2_ = g_list_nth_data (bytes, (guint) i);
				if (((gint) ((guint8) ((guintptr) _tmp2_))) == 0xAA) {
					ret = g_list_append (ret, (gpointer) ((guintptr) ((guint8) 0xAA)));
					ret = g_list_append (ret, (gpointer) ((guintptr) ((guint8) 0xAA)));
				} else {
					gconstpointer _tmp3_;
					_tmp3_ = g_list_nth_data (bytes, (guint) i);
					if (((gint) ((guint8) ((guintptr) _tmp3_))) == 0xAB) {
						ret = g_list_append (ret, (gpointer) ((guintptr) ((guint8) 0xAA)));
						ret = g_list_append (ret, (gpointer) ((guintptr) ((guint8) 0xAB)));
					} else {
						gconstpointer _tmp4_;
						_tmp4_ = g_list_nth_data (bytes, (guint) i);
						if (((gint) ((guint8) ((guintptr) _tmp4_))) == 0xAC) {
							ret = g_list_append (ret, (gpointer) ((guintptr) ((guint8) 0xAA)));
							ret = g_list_append (ret, (gpointer) ((guintptr) ((guint8) 0xAC)));
						} else {
							gconstpointer _tmp5_;
							_tmp5_ = g_list_nth_data (bytes, (guint) i);
							ret = g_list_append (ret, (gpointer) ((guintptr) ((guint8) ((guintptr) _tmp5_))));
						}
					}
				}
			}
		}
	}
	result = ret;
	return result;
}

static void
picolan_interface_write_list (picolanInterface* self,
                              GList* bytes)
{
	GArray* b = NULL;
	GArray* _tmp0_;
	gserialPort* _tmp5_;
	GArray* _tmp6_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_array_new (TRUE, TRUE, sizeof (gchar));
	b = _tmp0_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp1_ = FALSE;
			_tmp1_ = TRUE;
			while (TRUE) {
				GArray* _tmp3_;
				gconstpointer _tmp4_;
				if (!_tmp1_) {
					gint _tmp2_;
					_tmp2_ = i;
					i = _tmp2_ + 1;
				}
				_tmp1_ = FALSE;
				if (!(((guint) i) < g_list_length (bytes))) {
					break;
				}
				_tmp3_ = b;
				_tmp4_ = g_list_nth_data (bytes, (guint) i);
				g_array_append_val (_tmp3_, (gchar) ((guint8) ((guintptr) _tmp4_)));
			}
		}
	}
	_tmp5_ = self->priv->port;
	_tmp6_ = b;
	gserial_port_write (_tmp5_, _tmp6_, &_inner_error0_);
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_array_unref0 (b);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	_g_array_unref0 (b);
}

static void
picolan_interface_class_init (picolanInterfaceClass * klass,
                              gpointer klass_data)
{
	picolan_interface_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &picolanInterface_private_offset);
	G_OBJECT_CLASS (klass)->finalize = picolan_interface_finalize;
	picolan_interface_signals[PICOLAN_INTERFACE_ON_CLOSE_SIGNAL] = g_signal_new ("on-close", PICOLAN_TYPE_INTERFACE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	picolan_interface_signals[PICOLAN_INTERFACE_ON_DATAGRAM_SIGNAL] = g_signal_new ("on-datagram", PICOLAN_TYPE_INTERFACE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__UCHAR_UCHAR_UCHAR_POINTER, G_TYPE_NONE, 4, G_TYPE_UCHAR, G_TYPE_UCHAR, G_TYPE_UCHAR, G_TYPE_POINTER);
}

static void
picolan_interface_instance_init (picolanInterface * self,
                                 gpointer klass)
{
	self->priv = picolan_interface_get_instance_private (self);
	self->ttl = (guint8) 6;
	self->priv->address = (guint8) 0;
}

static void
picolan_interface_finalize (GObject * obj)
{
	picolanInterface * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PICOLAN_TYPE_INTERFACE, picolanInterface);
	_g_object_unref0 (self->priv->port);
	_g_object_unref0 (self->priv->parser);
	_g_object_unref0 (self->priv->port_map);
	G_OBJECT_CLASS (picolan_interface_parent_class)->finalize (obj);
}

GType
picolan_interface_get_type (void)
{
	static volatile gsize picolan_interface_type_id__volatile = 0;
	if (g_once_init_enter (&picolan_interface_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (picolanInterfaceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) picolan_interface_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (picolanInterface), 0, (GInstanceInitFunc) picolan_interface_instance_init, NULL };
		GType picolan_interface_type_id;
		picolan_interface_type_id = g_type_register_static (G_TYPE_OBJECT, "picolanInterface", &g_define_type_info, 0);
		picolanInterface_private_offset = g_type_add_instance_private (picolan_interface_type_id, sizeof (picolanInterfacePrivate));
		g_once_init_leave (&picolan_interface_type_id__volatile, picolan_interface_type_id);
	}
	return picolan_interface_type_id__volatile;
}

static Block3Data*
block3_data_ref (Block3Data* _data3_)
{
	g_atomic_int_inc (&_data3_->_ref_count_);
	return _data3_;
}

static void
block3_data_unref (void * _userdata_)
{
	Block3Data* _data3_;
	_data3_ = (Block3Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data3_->_ref_count_)) {
		_g_object_unref0 (_data3_->iface);
		g_slice_free (Block3Data, _data3_);
	}
}

static Block4Data*
block4_data_ref (Block4Data* _data4_)
{
	g_atomic_int_inc (&_data4_->_ref_count_);
	return _data4_;
}

static void
block4_data_unref (void * _userdata_)
{
	Block4Data* _data4_;
	_data4_ = (Block4Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data4_->_ref_count_)) {
		_g_object_unref0 (_data4_->dg);
		block3_data_unref (_data4_->_data3_);
		_data4_->_data3_ = NULL;
		g_slice_free (Block4Data, _data4_);
	}
}

static void
___lambda15_ (void)
{
	FILE* _tmp0_;
	_tmp0_ = stdout;
	fprintf (_tmp0_, "Port closed\n");
}

static void
____lambda15__picolan_interface_on_close (picolanInterface* _sender,
                                          gpointer self)
{
	___lambda15_ ();
}

static void
___lambda16_ (Block4Data* _data4_,
              GObject* obj,
              GAsyncResult* res)
{
	Block3Data* _data3_;
	gint time = 0;
	picolanInterface* _tmp0_;
	FILE* _tmp1_;
	GError* _inner_error0_ = NULL;
	_data3_ = _data4_->_data3_;
	g_return_if_fail (res != NULL);
	_tmp0_ = _data3_->iface;
	time = picolan_interface_ping_finish (_tmp0_, res, &_inner_error0_);
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	_tmp1_ = stdout;
	fprintf (_tmp1_, "time: %i\n", time);
}

static void
____lambda16__gasync_ready_callback (GObject* source_object,
                                     GAsyncResult* res,
                                     gpointer self)
{
	___lambda16_ (self, source_object, res);
	block4_data_unref (self);
}

static void
___lambda17_ (GList* data)
{
	FILE* _tmp0_;
	FILE* _tmp5_;
	_tmp0_ = stdout;
	fprintf (_tmp0_, "got some data\n");
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp1_ = FALSE;
			_tmp1_ = TRUE;
			while (TRUE) {
				FILE* _tmp3_;
				gconstpointer _tmp4_;
				if (!_tmp1_) {
					gint _tmp2_;
					_tmp2_ = i;
					i = _tmp2_ + 1;
				}
				_tmp1_ = FALSE;
				if (!(((guint) i) < g_list_length (data))) {
					break;
				}
				_tmp3_ = stdout;
				_tmp4_ = g_list_nth_data (data, (guint) i);
				fprintf (_tmp3_, "%i ", (gint) ((guint8) ((guintptr) _tmp4_)));
			}
		}
	}
	_tmp5_ = stdout;
	fprintf (_tmp5_, "\n");
}

static void
____lambda17__picolan_socket_on_data (picolanSocket* _sender,
                                      GList* data,
                                      gpointer self)
{
	___lambda17_ (data);
}

static gboolean
___lambda18_ (Block4Data* _data4_)
{
	Block3Data* _data3_;
	gboolean result = FALSE;
	picolanDatagram* _tmp0_;
	GError* _inner_error0_ = NULL;
	_data3_ = _data4_->_data3_;
	_tmp0_ = _data4_->dg;
	picolan_datagram_send_string (_tmp0_, (guint8) 1, (guint8) 20, "Hello world!!", &_inner_error0_);
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		gboolean _tmp1_ = FALSE;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return _tmp1_;
	}
	result = TRUE;
	return result;
}

static gboolean
____lambda18__gsource_func (gpointer self)
{
	gboolean result;
	result = ___lambda18_ (self);
	return result;
}

gint
_vala_main (void)
{
	gint result = 0;
	Block3Data* _data3_;
	picolanInterface* _tmp0_;
	GMainLoop* loop = NULL;
	GMainLoop* _tmp14_;
	GError* _inner_error0_ = NULL;
	_data3_ = g_slice_new0 (Block3Data);
	_data3_->_ref_count_ = 1;
	_tmp0_ = picolan_interface_new ();
	_data3_->iface = _tmp0_;
	{
		Block4Data* _data4_;
		picolanInterface* _tmp1_;
		picolanInterface* _tmp2_;
		picolanInterface* _tmp3_;
		picolanInterface* _tmp4_;
		picolanDatagram* _tmp5_;
		picolanDatagram* _tmp6_;
		picolanInterface* _tmp7_;
		picolanDatagram* _tmp8_;
		_data4_ = g_slice_new0 (Block4Data);
		_data4_->_ref_count_ = 1;
		_data4_->_data3_ = block3_data_ref (_data3_);
		_tmp1_ = _data3_->iface;
		picolan_interface_open (_tmp1_, "/dev/pts/4", 1000000, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			block4_data_unref (_data4_);
			_data4_ = NULL;
			goto __catch5_g_error;
		}
		_tmp2_ = _data3_->iface;
		g_signal_connect (_tmp2_, "on-close", (GCallback) ____lambda15__picolan_interface_on_close, NULL);
		_tmp3_ = _data3_->iface;
		picolan_interface_set_address (_tmp3_, (guint8) 6, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			block4_data_unref (_data4_);
			_data4_ = NULL;
			goto __catch5_g_error;
		}
		_tmp4_ = _data3_->iface;
		picolan_interface_ping (_tmp4_, (guint8) 1, (guint) 1000, ____lambda16__gasync_ready_callback, block4_data_ref (_data4_));
		_tmp5_ = picolan_datagram_new ((guint8) 80);
		_data4_->dg = _tmp5_;
		_tmp6_ = _data4_->dg;
		_tmp7_ = _data3_->iface;
		picolan_socket_bind ((picolanSocket*) _tmp6_, _tmp7_);
		_tmp8_ = _data4_->dg;
		g_signal_connect ((picolanSocket*) _tmp8_, "on-data", (GCallback) ____lambda17__picolan_socket_on_data, NULL);
		g_timeout_add_full (1, (guint) 1000, ____lambda18__gsource_func, block4_data_ref (_data4_), block4_data_unref);
		block4_data_unref (_data4_);
		_data4_ = NULL;
	}
	goto __finally5;
	__catch5_g_error:
	{
		GError* _error_ = NULL;
		FILE* _tmp9_;
		FILE* _tmp10_;
		GError* _tmp11_;
		const gchar* _tmp12_;
		_error_ = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp9_ = stdout;
		fprintf (_tmp9_, "Error caught\n");
		_tmp10_ = stdout;
		_tmp11_ = _error_;
		_tmp12_ = _tmp11_->message;
		fprintf (_tmp10_, "Error: %s\n", _tmp12_);
		_g_error_free0 (_error_);
	}
	__finally5:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		gint _tmp13_ = -1;
		block3_data_unref (_data3_);
		_data3_ = NULL;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return _tmp13_;
	}
	_tmp14_ = g_main_loop_new (NULL, FALSE);
	loop = _tmp14_;
	g_main_loop_run (loop);
	result = 0;
	_g_main_loop_unref0 (loop);
	block3_data_unref (_data3_);
	_data3_ = NULL;
	return result;
}

int
main (int argc,
      char ** argv)
{
	return _vala_main ();
}

