/* datagram.c generated by valac 0.44.3, the Vala compiler
 * generated from datagram.vala, do not modify */

#include <glib-object.h>
#include <glib.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>

#define PICOLAN_TYPE_SOCKET (picolan_socket_get_type ())
#define PICOLAN_SOCKET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PICOLAN_TYPE_SOCKET, picolanSocket))
#define PICOLAN_IS_SOCKET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PICOLAN_TYPE_SOCKET))
#define PICOLAN_SOCKET_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), PICOLAN_TYPE_SOCKET, picolanSocketIface))

typedef struct _picolanSocket picolanSocket;
typedef struct _picolanSocketIface picolanSocketIface;

#define PICOLAN_TYPE_INTERFACE (picolan_interface_get_type ())
#define PICOLAN_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PICOLAN_TYPE_INTERFACE, picolanInterface))
#define PICOLAN_INTERFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PICOLAN_TYPE_INTERFACE, picolanInterfaceClass))
#define PICOLAN_IS_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PICOLAN_TYPE_INTERFACE))
#define PICOLAN_IS_INTERFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PICOLAN_TYPE_INTERFACE))
#define PICOLAN_INTERFACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PICOLAN_TYPE_INTERFACE, picolanInterfaceClass))

typedef struct _picolanInterface picolanInterface;
typedef struct _picolanInterfaceClass picolanInterfaceClass;

#define PICOLAN_TYPE_DATAGRAM (picolan_datagram_get_type ())
#define PICOLAN_DATAGRAM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PICOLAN_TYPE_DATAGRAM, picolanDatagram))
#define PICOLAN_DATAGRAM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PICOLAN_TYPE_DATAGRAM, picolanDatagramClass))
#define PICOLAN_IS_DATAGRAM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PICOLAN_TYPE_DATAGRAM))
#define PICOLAN_IS_DATAGRAM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PICOLAN_TYPE_DATAGRAM))
#define PICOLAN_DATAGRAM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PICOLAN_TYPE_DATAGRAM, picolanDatagramClass))

typedef struct _picolanDatagram picolanDatagram;
typedef struct _picolanDatagramClass picolanDatagramClass;
typedef struct _picolanDatagramPrivate picolanDatagramPrivate;
enum  {
	PICOLAN_DATAGRAM_0_PROPERTY,
	PICOLAN_DATAGRAM_NUM_PROPERTIES
};
static GParamSpec* picolan_datagram_properties[PICOLAN_DATAGRAM_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _picolanSocketIface {
	GTypeInterface parent_iface;
	guint8 (*get_port) (picolanSocket* self);
	void (*bind) (picolanSocket* self, picolanInterface* iface);
};

struct _picolanDatagram {
	GObject parent_instance;
	picolanDatagramPrivate * priv;
	guint8 remote;
	guint timeout;
};

struct _picolanDatagramClass {
	GObjectClass parent_class;
};

struct _picolanDatagramPrivate {
	picolanInterface* iface;
	guint8 port;
};

typedef enum  {
	PICOLAN_PICOLAN_ERROR_COMS_FAULT,
	PICOLAN_PICOLAN_ERROR_PAYLOAD_TOO_BIG
} picolanPicolanError;
#define PICOLAN_PICOLAN_ERROR picolan_picolan_error_quark ()

static gint picolanDatagram_private_offset;
static gpointer picolan_datagram_parent_class = NULL;
static picolanSocketIface * picolan_datagram_picolan_socket_parent_iface = NULL;

GType picolan_interface_get_type (void) G_GNUC_CONST;
GType picolan_socket_get_type (void) G_GNUC_CONST;
GType picolan_datagram_get_type (void) G_GNUC_CONST;
picolanDatagram* picolan_datagram_new (guint8 _port);
picolanDatagram* picolan_datagram_construct (GType object_type,
                                             guint8 _port);
GQuark picolan_picolan_error_quark (void);
void picolan_datagram_send_bytes (picolanDatagram* self,
                                  guint8 dest,
                                  guint8 port,
                                  GeeArrayList* data,
                                  GError** error);
void picolan_interface_send_datagram (picolanInterface* self,
                                      guint8 dest,
                                      guint8 port,
                                      GeeArrayList* data,
                                      GError** error);
void picolan_datagram_send_string (picolanDatagram* self,
                                   guint8 dest,
                                   guint8 port,
                                   const gchar* str,
                                   GError** error);
static void picolan_datagram_real_bind (picolanSocket* base,
                                 picolanInterface* _iface);
gboolean picolan_interface_attach_socket (picolanInterface* self,
                                          picolanSocket* s);
static void __lambda15_ (picolanDatagram* self,
                  guint8 src,
                  guint8 dest,
                  guint8 _port,
                  GeeArrayList* payload);
static void ___lambda15__picolan_interface_on_datagram (picolanInterface* _sender,
                                                 guint8 src,
                                                 guint8 dest,
                                                 guint8 port,
                                                 GeeArrayList* payload,
                                                 gpointer self);
static guint8 picolan_datagram_real_get_port (picolanSocket* base);
static void picolan_datagram_finalize (GObject * obj);

static inline gpointer
picolan_datagram_get_instance_private (picolanDatagram* self)
{
	return G_STRUCT_MEMBER_P (self, picolanDatagram_private_offset);
}

picolanDatagram*
picolan_datagram_construct (GType object_type,
                            guint8 _port)
{
	picolanDatagram * self = NULL;
	self = (picolanDatagram*) g_object_new (object_type, NULL);
	self->priv->port = _port;
	self->timeout = (guint) 1000;
	return self;
}

picolanDatagram*
picolan_datagram_new (guint8 _port)
{
	return picolan_datagram_construct (PICOLAN_TYPE_DATAGRAM, _port);
}

void
picolan_datagram_send_bytes (picolanDatagram* self,
                             guint8 dest,
                             guint8 port,
                             GeeArrayList* data,
                             GError** error)
{
	static const gint MAX_SEGMENT_SIZE = 250;
	gint parts = 0;
	gint _tmp0_;
	gint _tmp1_;
	GeeArrayList* segment_data = NULL;
	gint remainder = 0;
	gint _tmp14_;
	gint _tmp15_;
	GeeArrayList* _tmp16_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (data != NULL);
	_tmp0_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) data);
	_tmp1_ = _tmp0_;
	parts = _tmp1_ / MAX_SEGMENT_SIZE;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				GeeArrayList* _tmp4_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp2_ = FALSE;
				if (!(i < parts)) {
					break;
				}
				_tmp4_ = gee_array_list_new (G_TYPE_UCHAR, NULL, NULL, NULL, NULL, NULL);
				_g_object_unref0 (segment_data);
				segment_data = _tmp4_;
				{
					gint j = 0;
					j = 0;
					{
						gboolean _tmp5_ = FALSE;
						_tmp5_ = TRUE;
						while (TRUE) {
							GeeArrayList* _tmp7_;
							gpointer _tmp8_;
							if (!_tmp5_) {
								gint _tmp6_;
								_tmp6_ = j;
								j = _tmp6_ + 1;
							}
							_tmp5_ = FALSE;
							if (!(j < MAX_SEGMENT_SIZE)) {
								break;
							}
							_tmp7_ = segment_data;
							_tmp8_ = gee_abstract_list_get ((GeeAbstractList*) data, (i * MAX_SEGMENT_SIZE) + j);
							gee_abstract_collection_add ((GeeAbstractCollection*) _tmp7_, (gpointer) ((guintptr) ((guint8) ((guintptr) _tmp8_))));
						}
					}
				}
				{
					picolanInterface* _tmp9_;
					GeeArrayList* _tmp10_;
					_tmp9_ = self->priv->iface;
					_tmp10_ = segment_data;
					picolan_interface_send_datagram (_tmp9_, dest, port, _tmp10_, &_inner_error0_);
					if (G_UNLIKELY (_inner_error0_ != NULL)) {
						goto __catch0_g_error;
					}
				}
				goto __finally0;
				__catch0_g_error:
				{
					GError* _error_ = NULL;
					GError* _tmp11_;
					const gchar* _tmp12_;
					GError* _tmp13_;
					_error_ = _inner_error0_;
					_inner_error0_ = NULL;
					_tmp11_ = _error_;
					_tmp12_ = _tmp11_->message;
					_tmp13_ = g_error_new (PICOLAN_PICOLAN_ERROR, PICOLAN_PICOLAN_ERROR_COMS_FAULT, "%s", _tmp12_);
					_inner_error0_ = _tmp13_;
					_g_error_free0 (_error_);
					goto __finally0;
				}
				__finally0:
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
					if (_inner_error0_->domain == PICOLAN_PICOLAN_ERROR) {
						g_propagate_error (error, _inner_error0_);
						_g_object_unref0 (segment_data);
						return;
					} else {
						_g_object_unref0 (segment_data);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
						g_clear_error (&_inner_error0_);
						return;
					}
				}
			}
		}
	}
	_tmp14_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) data);
	_tmp15_ = _tmp14_;
	remainder = _tmp15_ % 250;
	_tmp16_ = gee_array_list_new (G_TYPE_UCHAR, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (segment_data);
	segment_data = _tmp16_;
	{
		gint j = 0;
		j = 0;
		{
			gboolean _tmp17_ = FALSE;
			_tmp17_ = TRUE;
			while (TRUE) {
				GeeArrayList* _tmp19_;
				gpointer _tmp20_;
				if (!_tmp17_) {
					gint _tmp18_;
					_tmp18_ = j;
					j = _tmp18_ + 1;
				}
				_tmp17_ = FALSE;
				if (!(j < remainder)) {
					break;
				}
				_tmp19_ = segment_data;
				_tmp20_ = gee_abstract_list_get ((GeeAbstractList*) data, (parts * MAX_SEGMENT_SIZE) + j);
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp19_, (gpointer) ((guintptr) ((guint8) ((guintptr) _tmp20_))));
			}
		}
	}
	{
		picolanInterface* _tmp21_;
		GeeArrayList* _tmp22_;
		_tmp21_ = self->priv->iface;
		_tmp22_ = segment_data;
		picolan_interface_send_datagram (_tmp21_, dest, port, _tmp22_, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch1_g_error;
		}
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError* _error_ = NULL;
		GError* _tmp23_;
		const gchar* _tmp24_;
		GError* _tmp25_;
		_error_ = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp23_ = _error_;
		_tmp24_ = _tmp23_->message;
		_tmp25_ = g_error_new (PICOLAN_PICOLAN_ERROR, PICOLAN_PICOLAN_ERROR_COMS_FAULT, "%s", _tmp24_);
		_inner_error0_ = _tmp25_;
		_g_error_free0 (_error_);
		goto __finally1;
	}
	__finally1:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		if (_inner_error0_->domain == PICOLAN_PICOLAN_ERROR) {
			g_propagate_error (error, _inner_error0_);
			_g_object_unref0 (segment_data);
			return;
		} else {
			_g_object_unref0 (segment_data);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
	_g_object_unref0 (segment_data);
}

static gchar
string_get (const gchar* self,
            glong index)
{
	gchar result = '\0';
	gchar _tmp0_;
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = ((gchar*) self)[index];
	result = _tmp0_;
	return result;
}

void
picolan_datagram_send_string (picolanDatagram* self,
                              guint8 dest,
                              guint8 port,
                              const gchar* str,
                              GError** error)
{
	GeeArrayList* arr = NULL;
	GeeArrayList* _tmp0_;
	GeeArrayList* _tmp6_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (str != NULL);
	_tmp0_ = gee_array_list_new (G_TYPE_UCHAR, NULL, NULL, NULL, NULL, NULL);
	arr = _tmp0_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp1_ = FALSE;
			_tmp1_ = TRUE;
			while (TRUE) {
				gint _tmp3_;
				gint _tmp4_;
				GeeArrayList* _tmp5_;
				if (!_tmp1_) {
					gint _tmp2_;
					_tmp2_ = i;
					i = _tmp2_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp3_ = strlen (str);
				_tmp4_ = _tmp3_;
				if (!(i < _tmp4_)) {
					break;
				}
				_tmp5_ = arr;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp5_, (gpointer) ((guintptr) ((guint8) string_get (str, (glong) i))));
			}
		}
	}
	_tmp6_ = arr;
	picolan_datagram_send_bytes (self, dest, port, _tmp6_, &_inner_error0_);
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		if (_inner_error0_->domain == PICOLAN_PICOLAN_ERROR) {
			g_propagate_error (error, _inner_error0_);
			_g_object_unref0 (arr);
			return;
		} else {
			_g_object_unref0 (arr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
	_g_object_unref0 (arr);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static void
__lambda15_ (picolanDatagram* self,
             guint8 src,
             guint8 dest,
             guint8 _port,
             GeeArrayList* payload)
{
	g_return_if_fail (payload != NULL);
	if (self->priv->port == _port) {
		g_signal_emit_by_name ((picolanSocket*) self, "on-data", payload);
	}
}

static void
___lambda15__picolan_interface_on_datagram (picolanInterface* _sender,
                                            guint8 src,
                                            guint8 dest,
                                            guint8 port,
                                            GeeArrayList* payload,
                                            gpointer self)
{
	__lambda15_ ((picolanDatagram*) self, src, dest, port, payload);
}

static void
picolan_datagram_real_bind (picolanSocket* base,
                            picolanInterface* _iface)
{
	picolanDatagram * self;
	picolanInterface* _tmp0_;
	picolanInterface* _tmp1_;
	picolanInterface* _tmp2_;
	self = (picolanDatagram*) base;
	g_return_if_fail (_iface != NULL);
	_tmp0_ = _g_object_ref0 (_iface);
	_g_object_unref0 (self->priv->iface);
	self->priv->iface = _tmp0_;
	_tmp1_ = self->priv->iface;
	picolan_interface_attach_socket (_tmp1_, (picolanSocket*) self);
	_tmp2_ = self->priv->iface;
	g_signal_connect_object (_tmp2_, "on-datagram", (GCallback) ___lambda15__picolan_interface_on_datagram, self, 0);
}

static guint8
picolan_datagram_real_get_port (picolanSocket* base)
{
	picolanDatagram * self;
	guint8 result = 0U;
	self = (picolanDatagram*) base;
	result = self->priv->port;
	return result;
}

static void
picolan_datagram_class_init (picolanDatagramClass * klass,
                             gpointer klass_data)
{
	picolan_datagram_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &picolanDatagram_private_offset);
	G_OBJECT_CLASS (klass)->finalize = picolan_datagram_finalize;
}

static void
picolan_datagram_picolan_socket_interface_init (picolanSocketIface * iface,
                                                gpointer iface_data)
{
	picolan_datagram_picolan_socket_parent_iface = g_type_interface_peek_parent (iface);
	iface->bind = (void (*) (picolanSocket*, picolanInterface*)) picolan_datagram_real_bind;
	iface->get_port = (guint8 (*) (picolanSocket*)) picolan_datagram_real_get_port;
}

static void
picolan_datagram_instance_init (picolanDatagram * self,
                                gpointer klass)
{
	self->priv = picolan_datagram_get_instance_private (self);
	self->remote = (guint8) 0;
}

static void
picolan_datagram_finalize (GObject * obj)
{
	picolanDatagram * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PICOLAN_TYPE_DATAGRAM, picolanDatagram);
	g_signal_emit_by_name ((picolanSocket*) self, "on-destroy");
	_g_object_unref0 (self->priv->iface);
	G_OBJECT_CLASS (picolan_datagram_parent_class)->finalize (obj);
}

GType
picolan_datagram_get_type (void)
{
	static volatile gsize picolan_datagram_type_id__volatile = 0;
	if (g_once_init_enter (&picolan_datagram_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (picolanDatagramClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) picolan_datagram_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (picolanDatagram), 0, (GInstanceInitFunc) picolan_datagram_instance_init, NULL };
		static const GInterfaceInfo picolan_socket_info = { (GInterfaceInitFunc) picolan_datagram_picolan_socket_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType picolan_datagram_type_id;
		picolan_datagram_type_id = g_type_register_static (G_TYPE_OBJECT, "picolanDatagram", &g_define_type_info, 0);
		g_type_add_interface_static (picolan_datagram_type_id, PICOLAN_TYPE_SOCKET, &picolan_socket_info);
		picolanDatagram_private_offset = g_type_add_instance_private (picolan_datagram_type_id, sizeof (picolanDatagramPrivate));
		g_once_init_leave (&picolan_datagram_type_id__volatile, picolan_datagram_type_id);
	}
	return picolan_datagram_type_id__volatile;
}

