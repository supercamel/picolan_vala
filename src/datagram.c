/* datagram.c generated by valac 0.44.3, the Vala compiler
 * generated from datagram.vala, do not modify */

#include <glib-object.h>
#include <glib.h>
#include <stdlib.h>
#include <string.h>

#define PICOLAN_TYPE_SOCKET (picolan_socket_get_type ())
#define PICOLAN_SOCKET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PICOLAN_TYPE_SOCKET, picolanSocket))
#define PICOLAN_IS_SOCKET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PICOLAN_TYPE_SOCKET))
#define PICOLAN_SOCKET_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), PICOLAN_TYPE_SOCKET, picolanSocketIface))

typedef struct _picolanSocket picolanSocket;
typedef struct _picolanSocketIface picolanSocketIface;

#define PICOLAN_TYPE_INTERFACE (picolan_interface_get_type ())
#define PICOLAN_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PICOLAN_TYPE_INTERFACE, picolanInterface))
#define PICOLAN_INTERFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PICOLAN_TYPE_INTERFACE, picolanInterfaceClass))
#define PICOLAN_IS_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PICOLAN_TYPE_INTERFACE))
#define PICOLAN_IS_INTERFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PICOLAN_TYPE_INTERFACE))
#define PICOLAN_INTERFACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PICOLAN_TYPE_INTERFACE, picolanInterfaceClass))

typedef struct _picolanInterface picolanInterface;
typedef struct _picolanInterfaceClass picolanInterfaceClass;

#define PICOLAN_TYPE_DATAGRAM (picolan_datagram_get_type ())
#define PICOLAN_DATAGRAM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PICOLAN_TYPE_DATAGRAM, picolanDatagram))
#define PICOLAN_DATAGRAM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PICOLAN_TYPE_DATAGRAM, picolanDatagramClass))
#define PICOLAN_IS_DATAGRAM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PICOLAN_TYPE_DATAGRAM))
#define PICOLAN_IS_DATAGRAM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PICOLAN_TYPE_DATAGRAM))
#define PICOLAN_DATAGRAM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PICOLAN_TYPE_DATAGRAM, picolanDatagramClass))

typedef struct _picolanDatagram picolanDatagram;
typedef struct _picolanDatagramClass picolanDatagramClass;
typedef struct _picolanDatagramPrivate picolanDatagramPrivate;
enum  {
	PICOLAN_DATAGRAM_0_PROPERTY,
	PICOLAN_DATAGRAM_NUM_PROPERTIES
};
static GParamSpec* picolan_datagram_properties[PICOLAN_DATAGRAM_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _picolanSocketIface {
	GTypeInterface parent_iface;
	guint8 (*get_port) (picolanSocket* self);
	void (*bind) (picolanSocket* self, picolanInterface* iface);
};

struct _picolanDatagram {
	GObject parent_instance;
	picolanDatagramPrivate * priv;
	guint8 remote;
	guint timeout;
};

struct _picolanDatagramClass {
	GObjectClass parent_class;
};

struct _picolanDatagramPrivate {
	picolanInterface* iface;
	guint8 port;
};

typedef enum  {
	PICOLAN_PICOLAN_ERROR_COMS_FAULT,
	PICOLAN_PICOLAN_ERROR_PAYLOAD_TOO_BIG
} picolanPicolanError;
#define PICOLAN_PICOLAN_ERROR picolan_picolan_error_quark ()

static gint picolanDatagram_private_offset;
static gpointer picolan_datagram_parent_class = NULL;
static picolanSocketIface * picolan_datagram_picolan_socket_parent_iface = NULL;

GType picolan_interface_get_type (void) G_GNUC_CONST;
GType picolan_socket_get_type (void) G_GNUC_CONST;
GType picolan_datagram_get_type (void) G_GNUC_CONST;
picolanDatagram* picolan_datagram_new (guint8 _port);
picolanDatagram* picolan_datagram_construct (GType object_type,
                                             guint8 _port);
GQuark picolan_picolan_error_quark (void);
void picolan_datagram_send_bytes (picolanDatagram* self,
                                  guint8 dest,
                                  guint8 port,
                                  GList* data,
                                  GError** error);
void picolan_interface_send_datagram (picolanInterface* self,
                                      guint8 dest,
                                      guint8 port_num,
                                      GList* data,
                                      GError** error);
void picolan_datagram_send_string (picolanDatagram* self,
                                   guint8 dest,
                                   guint8 port,
                                   const gchar* str,
                                   GError** error);
static void picolan_datagram_real_bind (picolanSocket* base,
                                 picolanInterface* _iface);
gboolean picolan_interface_attach_socket (picolanInterface* self,
                                          picolanSocket* s);
static void __lambda14_ (picolanDatagram* self,
                  guint8 src,
                  guint8 dest,
                  guint8 _port,
                  GList* payload);
static void ___lambda14__picolan_interface_on_datagram (picolanInterface* _sender,
                                                 guint8 src,
                                                 guint8 dest,
                                                 guint8 port,
                                                 GList* payload,
                                                 gpointer self);
static guint8 picolan_datagram_real_get_port (picolanSocket* base);
static void picolan_datagram_finalize (GObject * obj);

static inline gpointer
picolan_datagram_get_instance_private (picolanDatagram* self)
{
	return G_STRUCT_MEMBER_P (self, picolanDatagram_private_offset);
}

picolanDatagram*
picolan_datagram_construct (GType object_type,
                            guint8 _port)
{
	picolanDatagram * self = NULL;
	self = (picolanDatagram*) g_object_new (object_type, NULL);
	self->priv->port = _port;
	self->timeout = (guint) 1000;
	return self;
}

picolanDatagram*
picolan_datagram_new (guint8 _port)
{
	return picolan_datagram_construct (PICOLAN_TYPE_DATAGRAM, _port);
}

void
picolan_datagram_send_bytes (picolanDatagram* self,
                             guint8 dest,
                             guint8 port,
                             GList* data,
                             GError** error)
{
	static const guint MAX_SEGMENT_SIZE = (guint) 250;
	guint parts = 0U;
	GList* segment_data = NULL;
	guint remainder = 0U;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	parts = g_list_length (data) / MAX_SEGMENT_SIZE;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					gint _tmp1_;
					_tmp1_ = i;
					i = _tmp1_ + 1;
				}
				_tmp0_ = FALSE;
				if (!(((guint) i) < parts)) {
					break;
				}
				(segment_data == NULL) ? NULL : (segment_data = (g_list_free (segment_data), NULL));
				segment_data = NULL;
				{
					gint j = 0;
					j = 0;
					{
						gboolean _tmp2_ = FALSE;
						_tmp2_ = TRUE;
						while (TRUE) {
							gconstpointer _tmp4_;
							if (!_tmp2_) {
								gint _tmp3_;
								_tmp3_ = j;
								j = _tmp3_ + 1;
							}
							_tmp2_ = FALSE;
							if (!(((guint) j) < MAX_SEGMENT_SIZE)) {
								break;
							}
							_tmp4_ = g_list_nth_data (data, (i * MAX_SEGMENT_SIZE) + j);
							segment_data = g_list_append (segment_data, (gpointer) ((guintptr) ((guint8) ((guintptr) _tmp4_))));
						}
					}
				}
				{
					picolanInterface* _tmp5_;
					GList* _tmp6_;
					_tmp5_ = self->priv->iface;
					_tmp6_ = segment_data;
					picolan_interface_send_datagram (_tmp5_, dest, port, _tmp6_, &_inner_error0_);
					if (G_UNLIKELY (_inner_error0_ != NULL)) {
						goto __catch0_g_error;
					}
				}
				goto __finally0;
				__catch0_g_error:
				{
					GError* _error_ = NULL;
					GError* _tmp7_;
					const gchar* _tmp8_;
					GError* _tmp9_;
					_error_ = _inner_error0_;
					_inner_error0_ = NULL;
					_tmp7_ = _error_;
					_tmp8_ = _tmp7_->message;
					_tmp9_ = g_error_new (PICOLAN_PICOLAN_ERROR, PICOLAN_PICOLAN_ERROR_COMS_FAULT, "%s", _tmp8_);
					_inner_error0_ = _tmp9_;
					_g_error_free0 (_error_);
					goto __finally0;
				}
				__finally0:
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
					if (_inner_error0_->domain == PICOLAN_PICOLAN_ERROR) {
						g_propagate_error (error, _inner_error0_);
						(segment_data == NULL) ? NULL : (segment_data = (g_list_free (segment_data), NULL));
						return;
					} else {
						(segment_data == NULL) ? NULL : (segment_data = (g_list_free (segment_data), NULL));
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
						g_clear_error (&_inner_error0_);
						return;
					}
				}
			}
		}
	}
	remainder = g_list_length (data) % 250;
	(segment_data == NULL) ? NULL : (segment_data = (g_list_free (segment_data), NULL));
	segment_data = NULL;
	{
		gint j = 0;
		j = 0;
		{
			gboolean _tmp10_ = FALSE;
			_tmp10_ = TRUE;
			while (TRUE) {
				gconstpointer _tmp12_;
				if (!_tmp10_) {
					gint _tmp11_;
					_tmp11_ = j;
					j = _tmp11_ + 1;
				}
				_tmp10_ = FALSE;
				if (!(((guint) j) < remainder)) {
					break;
				}
				_tmp12_ = g_list_nth_data (data, (parts * MAX_SEGMENT_SIZE) + j);
				segment_data = g_list_append (segment_data, (gpointer) ((guintptr) ((guint8) ((guintptr) _tmp12_))));
			}
		}
	}
	{
		picolanInterface* _tmp13_;
		GList* _tmp14_;
		_tmp13_ = self->priv->iface;
		_tmp14_ = segment_data;
		picolan_interface_send_datagram (_tmp13_, dest, port, _tmp14_, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch1_g_error;
		}
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError* _error_ = NULL;
		GError* _tmp15_;
		const gchar* _tmp16_;
		GError* _tmp17_;
		_error_ = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp15_ = _error_;
		_tmp16_ = _tmp15_->message;
		_tmp17_ = g_error_new (PICOLAN_PICOLAN_ERROR, PICOLAN_PICOLAN_ERROR_COMS_FAULT, "%s", _tmp16_);
		_inner_error0_ = _tmp17_;
		_g_error_free0 (_error_);
		goto __finally1;
	}
	__finally1:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		if (_inner_error0_->domain == PICOLAN_PICOLAN_ERROR) {
			g_propagate_error (error, _inner_error0_);
			(segment_data == NULL) ? NULL : (segment_data = (g_list_free (segment_data), NULL));
			return;
		} else {
			(segment_data == NULL) ? NULL : (segment_data = (g_list_free (segment_data), NULL));
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
	(segment_data == NULL) ? NULL : (segment_data = (g_list_free (segment_data), NULL));
}

static gchar
string_get (const gchar* self,
            glong index)
{
	gchar result = '\0';
	gchar _tmp0_;
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = ((gchar*) self)[index];
	result = _tmp0_;
	return result;
}

void
picolan_datagram_send_string (picolanDatagram* self,
                              guint8 dest,
                              guint8 port,
                              const gchar* str,
                              GError** error)
{
	GList* arr = NULL;
	GList* _tmp4_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (str != NULL);
	arr = NULL;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				gint _tmp2_;
				gint _tmp3_;
				if (!_tmp0_) {
					gint _tmp1_;
					_tmp1_ = i;
					i = _tmp1_ + 1;
				}
				_tmp0_ = FALSE;
				_tmp2_ = strlen (str);
				_tmp3_ = _tmp2_;
				if (!(i < _tmp3_)) {
					break;
				}
				arr = g_list_append (arr, (gpointer) ((guintptr) ((guint8) string_get (str, (glong) i))));
			}
		}
	}
	_tmp4_ = arr;
	picolan_datagram_send_bytes (self, dest, port, _tmp4_, &_inner_error0_);
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		if (_inner_error0_->domain == PICOLAN_PICOLAN_ERROR) {
			g_propagate_error (error, _inner_error0_);
			(arr == NULL) ? NULL : (arr = (g_list_free (arr), NULL));
			return;
		} else {
			(arr == NULL) ? NULL : (arr = (g_list_free (arr), NULL));
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
	(arr == NULL) ? NULL : (arr = (g_list_free (arr), NULL));
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static void
__lambda14_ (picolanDatagram* self,
             guint8 src,
             guint8 dest,
             guint8 _port,
             GList* payload)
{
	if (self->priv->port == _port) {
		g_signal_emit_by_name ((picolanSocket*) self, "on-data", payload);
	}
}

static void
___lambda14__picolan_interface_on_datagram (picolanInterface* _sender,
                                            guint8 src,
                                            guint8 dest,
                                            guint8 port,
                                            GList* payload,
                                            gpointer self)
{
	__lambda14_ ((picolanDatagram*) self, src, dest, port, payload);
}

static void
picolan_datagram_real_bind (picolanSocket* base,
                            picolanInterface* _iface)
{
	picolanDatagram * self;
	picolanInterface* _tmp0_;
	picolanInterface* _tmp1_;
	picolanInterface* _tmp2_;
	self = (picolanDatagram*) base;
	g_return_if_fail (_iface != NULL);
	_tmp0_ = _g_object_ref0 (_iface);
	_g_object_unref0 (self->priv->iface);
	self->priv->iface = _tmp0_;
	_tmp1_ = self->priv->iface;
	picolan_interface_attach_socket (_tmp1_, (picolanSocket*) self);
	_tmp2_ = self->priv->iface;
	g_signal_connect_object (_tmp2_, "on-datagram", (GCallback) ___lambda14__picolan_interface_on_datagram, self, 0);
}

static guint8
picolan_datagram_real_get_port (picolanSocket* base)
{
	picolanDatagram * self;
	guint8 result = 0U;
	self = (picolanDatagram*) base;
	result = self->priv->port;
	return result;
}

static void
picolan_datagram_class_init (picolanDatagramClass * klass,
                             gpointer klass_data)
{
	picolan_datagram_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &picolanDatagram_private_offset);
	G_OBJECT_CLASS (klass)->finalize = picolan_datagram_finalize;
}

static void
picolan_datagram_picolan_socket_interface_init (picolanSocketIface * iface,
                                                gpointer iface_data)
{
	picolan_datagram_picolan_socket_parent_iface = g_type_interface_peek_parent (iface);
	iface->bind = (void (*) (picolanSocket*, picolanInterface*)) picolan_datagram_real_bind;
	iface->get_port = (guint8 (*) (picolanSocket*)) picolan_datagram_real_get_port;
}

static void
picolan_datagram_instance_init (picolanDatagram * self,
                                gpointer klass)
{
	self->priv = picolan_datagram_get_instance_private (self);
	self->remote = (guint8) 0;
}

static void
picolan_datagram_finalize (GObject * obj)
{
	picolanDatagram * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PICOLAN_TYPE_DATAGRAM, picolanDatagram);
	g_signal_emit_by_name ((picolanSocket*) self, "on-destroy");
	_g_object_unref0 (self->priv->iface);
	G_OBJECT_CLASS (picolan_datagram_parent_class)->finalize (obj);
}

GType
picolan_datagram_get_type (void)
{
	static volatile gsize picolan_datagram_type_id__volatile = 0;
	if (g_once_init_enter (&picolan_datagram_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (picolanDatagramClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) picolan_datagram_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (picolanDatagram), 0, (GInstanceInitFunc) picolan_datagram_instance_init, NULL };
		static const GInterfaceInfo picolan_socket_info = { (GInterfaceInitFunc) picolan_datagram_picolan_socket_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType picolan_datagram_type_id;
		picolan_datagram_type_id = g_type_register_static (G_TYPE_OBJECT, "picolanDatagram", &g_define_type_info, 0);
		g_type_add_interface_static (picolan_datagram_type_id, PICOLAN_TYPE_SOCKET, &picolan_socket_info);
		picolanDatagram_private_offset = g_type_add_instance_private (picolan_datagram_type_id, sizeof (picolanDatagramPrivate));
		g_once_init_leave (&picolan_datagram_type_id__volatile, picolan_datagram_type_id);
	}
	return picolan_datagram_type_id__volatile;
}

